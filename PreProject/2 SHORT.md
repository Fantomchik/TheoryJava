## Вопросы
- [1. Что такое бин?](#1-что-такое-bean-в-контексте-spring-вопросы)
- [2. Виды бинов?](#2-виды-бинов-вопросы)
- [3. Чем бин отличается от POJO-класса?](#3-чем-бин-отличается-от-pojo-класса-вопросы)
- [4. Что такое Inversion of Control и как Spring реализует этот принцип?](#4-что-такое-inversion-of-control-и-как-spring-реализует-этот-принцип-вопросы)
- - [`ДОП` Какие классы могут быть бинами в Spring?](#доп-какие-классы-могут-быть-бинами-в-спринг-вопросы) 
- - [`ДОП` Как реализован IoC-контейнер? Что за сущность это в Java? (типа массив или что-то ещё)](#доп-как-реализован-ioc-контейнер-что-за-сущность-это-в-java-типа-массив-или-что-то-ещё-вопросы)
- [5. Для чего существует такое количество ApplicationContext?](#5-для-чего-существует-такое-количество-applicationcontext-вопросы)
- [6. Как можно связать бины?](#6-как-можно-связать-бины-вопросы)
- - [`ДОП` MockBean Что это?](#доп-mockbean-что-это-вопросы)
- [7. Что такое Dependency Injection?](#7-что-такое-dependency-injection-вопросы)
- [8. Какие бины будут использоваться для настройки приложения?](#8-какие-бины-будут-использоваться-для-настройки-приложения-вопросы)
- [9. Как получить данные из файла .property?](#9-как-получить-данные-из-файла-property-вопросы)
- [10. Как запустить Спринг-приложение из-под сервера Tomcat?](#10-как-запустить-спринг-приложение-из-под-сервера-tomcat-вопросы)
- [11. Что такое Artifacts?](#11-что-такое-artifacts-вопросы)
- [12. В чем отличие артефакта war от war exploded?](#12-в-чем-отличие-артефакта-war-от-war-exploded-вопросы)
- [13. Какая разница между аннотациями @Component, @Repository и @Service в Spring?](#13-какая-разница-между-аннотациями-component-repository-и-service-в-spring-вопросы)
- [14. Как выглядит структура MVC-приложения?](#14-как-выглядит-структура-mvc-приложения-вопросы)
- - [`ДОП` Зачем нам нужен слой Servise and Repository если модель называется MVC? А не MVCSR!](#доп-зачем-нам-нужен-слой-servise-and-repository-если-модель-называется-mvc-а-не-mvcsr-вопросы)
- - [`ДОП` Что такое Servlet? Что такое DispatcherServlet?](#доп-что-такое-servlet-что-такое-dispatcherservlet-вопросы)
- - [`ДОП` Как контроллер связан c сервлетом?](#доп-как-контроллер-связан-c-сервлетом-вопросы)
- [15. Чем контроллер отличается от сервлета?](#15-чем-контроллер-controller-отличается-от-сервлета-servlet-вопросы)
- [16. Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?](#16-какая-основная-зависимость-фреймворка-spring-почему-во-многих-сборках-она-не-указывается-явно-вопросы)
- [17. Как вернуть страницу в контроллере? Как вернуть данные?](#17-как-вернуть-страницу-в-контроллере-как-вернуть-данные-вопросы)
- [18. Уметь рассказать про принципы работы Spring.](#18-уметь-рассказать-про-принципы-работы-spring-вопросы)
- [19. Связывание бинов и их жизненный цикл.](#19-связывание-бинов-и-их-жизненный-цикл-вопросы)
- [20. Основные паттерны Spring.](#20-основные-паттерны-spring-вопросы)
- - [`ДОП` Чем фреймворк отличается от библиотеки?](#доп-чем-фреймворк-отличается-от-библиотеки-вопросы)
- - [`ДОП` Какие есть причины использования Spring? Для чего вообще он нужен?](#доп-какие-есть-причины-использования-spring-для-чего-вообще-он-нужен-вопросы)
- - [`ДОП` Какой жизненный цикл контейнера Spring?](#доп-какой-жизненный-цикл-контейнера-spring-вопросы)

## 1. Что такое bean в контексте spring? [вопросы](#вопросы)

Bean — это объект, управляемый контейнером Spring. Любой компонент, который Spring создает, настраивает и управляет его жизненным циклом.

## 2. Виды бинов? [вопросы](#вопросы)

✅ **1\. По назначению**
-----------------------

*   **`@Component`** — базовый тип бина. Используется для создания общих компонентов.
*   **`@Service`** — используется для бизнес-логики.
*   **`@Repository`** — используется для взаимодействия с базой данных.
*   **`@Controller`** — используется в Spring MVC для обработки HTTP-запросов.
*   **`@RestController`** — разновидность `@Controller`, которая автоматически сериализует данные в JSON или XML.

✅ **2\. По области видимости (Scope)**
--------------------------------------

Область видимости (`@Scope`) определяет, сколько экземпляров бина будет создано и как долго они будут существовать.

*   **`singleton`** _(по умолчанию)_ — создается один экземпляр на весь контекст Spring.
*   **`prototype`** — создается новый экземпляр при каждом запросе.
*   **`request`** — один экземпляр на HTTP-запрос (только в Spring Web).
*   **`session`** — один экземпляр на сессию пользователя.
*   **`application`** — один экземпляр на всё приложение (аналог Singleton, но для веб-контекста).
*   **`WebSocket`** — один экземпляр bean для каждого WebSocket-соединения(для работы с чатами или потоковыми данными в реальном времени).

✅ **3\. По способу создания**
-----------------------------

*   **Через аннотации** — с использованием `@Component`, `@Service` и других аннотаций.
*   **Через Java-конфигурацию** — с `@Configuration` и `@Bean`.
*   **Через XML-конфигурацию** — если используется старый стиль конфигурации Spring.

✅ **4\. По типу управления**
----------------------------

*   **Managed Beans** — стандартные Spring-бины, созданные и управляемые контейнером Spring.
*   **External Beans** — объекты, созданные вне Spring, но внедрённые в контекст с помощью `@Bean` или `@Configuration`.
*   **Factory Beans** — создаются с использованием `FactoryBean<T>` для более сложных сценариев.

## 3. Чем бин отличается от POJO-класса? [вопросы](#вопросы)

| **Критерий** | **Bean** | **POJO** |
| --- | --- | --- |
| **Определение** | Объект, управляемый контейнером Spring (Spring Bean). | Простая структура данных (Plain Old Java Object). |
| **Управление** | Управляется Spring (жизненный цикл, зависимости). | Не управляется никаким контейнером. |
| **Аннотации** | Использует аннотации: `@Component`, `@Service`, `@Repository`, `@Controller`. | Не требует аннотаций или конфигураций. |
| **Инъекция зависимостей** | Поддерживает внедрение зависимостей через Spring. | Внедрение нужно делать вручную. |
| **Жизненный цикл** | Контейнер контролирует создание, инициализацию и уничтожение. | Жизненный цикл управляется вручную или JVM. |
| **Использование** | Используется в бизнес-логике, сервисах, контроллерах. | Используется как модель данных или DTO. |
| **Примерное поведение** | Может иметь сложную бизнес-логику и зависимости. | Обычно содержит только поля, геттеры, сеттеры. |

все Spring-бины — это POJO, но не все POJO — бины


## 4. Что такое Inversion of Control и как Spring реализует этот принцип? [вопросы](#вопросы)

**Inversion of Control (IoC)** — это принцип, при котором управление созданием и жизненным циклом объектов передаётся внешнему контейнеру или фреймворку. Вместо того чтобы класс самостоятельно создавать свои зависимости с помощью `new`, контейнер предоставляет эти зависимости.

✅ **Как работает IoC в Spring?**
--------------------------------

Spring реализует IoC с помощью **контейнера** Spring, который:

1.  **Создаёт** бины (объекты) на основе конфигурации(XML, java, annotation).
2.  **Управляет** их жизненным циклом.
3.  **Внедряет зависимости** (Dependency Injection)(конструкторы, сеттеры, поля).
4.  **Контролирует** жизненный цикл бинов(`@PostConstruct` и `@PreDestroy`).

## `ДОП` Какие классы могут быть бинами в спринг? [вопросы](#вопросы)

*   Классы с аннотациями `@Component`, `@Service`, `@Repository`, `@Controller`, `@RestController`.
*   Классы, возвращаемые методами с `@Bean`.
*   Фабричные бины с `FactoryBean`.
*   Любые классы, если их создание и управление передано Spring.

## `ДОП` Как реализован IoC-контейнер? Что за сущность это в Java? (типа массив или что-то ещё) [вопросы](#вопросы)

*   Это **объект в памяти**, который содержит бины и управляет ими.
*   Работает как **Map**, где ключ — это имя или тип бина, а значение — сам объект.
*   Может поддерживать сложные зависимости и связывать их между собой.
*   Реализует принципы **Inversion of Control (IoC)** и **Dependency Injection (DI)**.

1.  **`BeanFactory`** — Базовый контейнер, который используется в простых приложениях.
    *   Ленивая инициализация (бин создаётся только при первом запросе).
2.  **`ApplicationContext`** — Более функциональный контейнер, который чаще всего используется.
    *   Поддерживает события, интернационализацию, аннотации и обработчики.
3.  **`AnnotationConfigApplicationContext`** — Контейнер для приложений, сконфигурированных с аннотациями.
4.  **`XmlWebApplicationContext`** — Используется в приложениях с конфигурацией через XML.

## 5. Для чего существует такое количество ApplicationContext? [вопросы](#вопросы)

1.  **Разные источники конфигурации**
    
    *   Конфигурация может быть написана в **Java** (`@Configuration`), в **XML** или быть миксом обоих.
    *   Разные `ApplicationContext` работают с соответствующими источниками данных.
2.  **Среда выполнения**
    
    *   Приложения могут быть **десктопными**, **веб-приложениями** или **микросервисами**.
    *   Есть контейнеры, специально адаптированные для веб-среды (`WebApplicationContext`).
3.  **Управление жизненным циклом**
    
    *   Некоторые контейнеры поддерживают дополнительные функции, такие как обработка веб-запросов или управление сессиями.
4.  **Удобство тестирования**
    
    *   Есть лёгкие контейнеры (`GenericApplicationContext`) для быстрого тестирования.

| **Контекст** | **Описание** | **Когда использовать** |
| --- | --- | --- |
| `AnnotationConfigApplicationContext` | Конфигурация через аннотации `@Configuration`. | При использовании Spring без XML. |
| `ClassPathXmlApplicationContext` | Чтение конфигурации из XML-файлов. | Когда проект уже использует XML или требуется миграция. |
| `FileSystemXmlApplicationContext` | Загружает XML-конфигурацию по пути к файлу. | При конфигурации вне `classpath`. |
| `GenericApplicationContext` | Универсальный контейнер. Поддерживает аннотации и XML. | Для тестов или простых приложений. |
| `AnnotationConfigWebApplicationContext` | Контекст для веб-приложений с аннотациями. | В Spring Boot и Spring MVC. |
| `XmlWebApplicationContext` | Конфигурация веб-приложений через XML. | Для устаревших приложений или тех, что требуют XML. |
| `WebApplicationContext` | Расширение `ApplicationContext` для работы с HTTP-запросами. | Веб-приложения с поддержкой сессий и запросов. |

## 6. Как можно связать бины? [вопросы](#вопросы)

| **Способ** | **Когда использовать** |
| --- | --- |
| `@Autowired` | Когда бин можно однозначно определить. |
| `@Qualifier` | Когда есть несколько реализаций интерфейса. |
| `@Primary` | Если нужно задать бин по умолчанию. |
| Конструкторное связывание | Когда все зависимости обязательны и должны быть `final`(иммутабельными). |
| Сеттерное связывание | Когда зависимость может быть необязательной. |
| Полевая инъекция | Для простоты, но лучше избегать в серьёзных приложениях. |
| `@Bean`\-методы | При необходимости явного контроля за созданием объектов. |
| `@Resource` | из JSR-250 для внедрения по имени. |
| `@Inject` | из JSR-330 работает аналогично @Autowired. |

## `ДОП` MockBean Что это? [вопросы](#вопросы)

`@MockBean` — это аннотация из Spring Boot, которая используется для создания **мока (mock)** с использованием библиотеки **Mockito**. Она чаще всего применяется в **юнит-тестах** или **интеграционных тестах** для подмены реальных бинов мок-объектами.

1.  **`@SpringBootTest`** — Поднимает контекст Spring и тестирует приложение целиком.
2.  **`@MockBean`** — Создаёт мок-объект для `OrderRepository` и регистрирует его в контексте.
3.  **`Mockito.when()`** — Задаёт поведение мок-объекта при вызове метода.
4.  **`Assertions.assertEquals()`** — Проверяет ожидаемый результат.

| **Аспект** | **@MockBean** | **@Mock** |
| --- | --- | --- |
| **Где используется** | В Spring Boot тестах с контекстом (`@SpringBootTest`). | В обычных юнит-тестах без Spring. |
| **Регистрация** | Регистрирует мок в контексте Spring. | Не регистрирует мок в контексте. |
| **Интеграция** | Может заменить реальный бин. | Используется только для Mockito тестов. |
| **Использование** | Для тестов компонентов с зависимостями. | Для изолированных юнит-тестов. |

## 7. Что такое Dependency Injection? [вопросы](#вопросы)

**Dependency Injection (DI)** - это паттерн проектирования, который позволяет управлять зависимостями между объектами и их конфигурацией в приложении. Основная идея `DI` заключается в том, что объекты не создают свои зависимости сами, а получают их извне. Это упрощает тестирование, повышает модульность и делает код более гибким.

В `Spring` это реализовано через `IoC-контейнер`, который управляет жизненным циклом объектов и их зависимостями. Внедряет зависимости через конструкторы, поля и сеттеры. Ищет зависимости по аннотациям **`@Autowired`** **`@Qualifier`** **`@Primary`**  **`@ComponentScan`**.

## 8. Какие бины будут использоваться для настройки приложения? [вопросы](#вопросы)

*   **Конфигурационные классы** (`@Configuration`)
*   **Бины, определённые через `@Bean`**(фабрики)
*   **Настройки через `@Value`(конфигурационных файлов) и `@PropertySource`(внешние файлы)**
*   **Сканирование компонентов** с помощью `@ComponentScan`(в каком пакете искать)
*   **Профили через `@Profile`(для разных сценаривев использования `dev` `prod`)**
*   **Автоматическая настройка в Spring Boot** с `@EnableAutoConfiguration`
*   **Настройки безопасности** через `@EnableWebSecurity`(интеграция кастомных механизмов безопасности(авторизация, аутентификация))
*   **Привязка настроек к POJO с `@ConfigurationProperties`**

## 9. Как получить данные из файла .property? [вопросы](#вопросы)

1.  **Через `@Value`** — для извлечения конкретных значений.
2.  **Через `@ConfigurationProperties`** — для привязки всех настроек в объект POJO.
3.  **Через `@PropertySource`** — если файл `.properties` не является стандартным `application.properties` и находится в другом месте.
4.  **Использование `Environment` для доступа к свойствам** - объект, хронящий в себе настройки.

## 10. Как запустить Спринг-приложение из-под сервера Tomcat? [вопросы](#вопросы)

**1\. Добавить maven-war-plugin**
**2\.Создание конфигурационного файла web.xml (если не используете Spring Boot)**
**3\.Сборка WAR-файла**
**4\.Развертывание на Tomcat**
**5\.Запуск Tomcat**
**6\.Доступ к приложению**

## 11. Что такое Artifacts? [вопросы](#вопросы)

**artifact** обозначает результат процесса разработки. 

1. **Исполняемые файлы** - **JAR** (Java ARchive), **WAR** (Web ARchive), **EAR** (Enterprise ARchive), содержащие скомпилированный код.
2. **Библиотеки**  
3. **Ресурсы** - конфиг, изо, доки, кот необходими апликации.
4. **Документация** - например Javadoc
5. **Скрипты** - для развёртывания, миграции данных или тестов.

Артефакты могут быть созданы при сборке, тестировании, развёртывании. 

## 12. В чем отличие артефакта war от war exploded? [вопросы](#вопросы)

| Характеристика | **WAR** | **WAR Exploded** |
| --- | --- | --- |
| **Формат** | Архивированный (файл .war) | Развернутая структура папок и файлов |
| **Использование** | Подходит для продакшн развертывания | Удобен для разработки и тестирования |
| **Процесс развертывания** | Требуется распаковка на сервере | Сервер может работать с развернутыми файлами напрямую |
| **Отслеживание изменений** | Нужно пересоздавать архив при изменении | Изменения видны сразу, не требуется перезапуск сервера |
| **Размер** | Обычно меньше, чем WAR Exploded | Может быть больше из-за наличия всех файлов без сжатия |

## 13. Какая разница между аннотациями @Component, @Repository и @Service в Spring? [вопросы](#вопросы)

| Аннотация | Описание | Пример использования | Когда использовать |
| --- | --- | --- | --- |
| **`@Component`** | Общая аннотация для компонента | Вспомогательные классы | Когда класс не попадает под специфические категории, например, утилиты. |
| **`@Repository`** | Добавляет поддержку обработки исключений базы данных | Репозитории, DAO, JPA, Hibernate | Для классов, осуществляющих доступ к данным, работы с базой данных. |
| **`@Service`** | Аннотация для бизнес-слоя, предоставляющего сервисы | Логика бизнес-сервисов | Для сервисов, содержащих бизнес-логику, которая обрабатывает данные. |

## 14. Как выглядит структура MVC-приложения? [вопросы](#вопросы)

*   **Модель** (Model) — данные и бизнес-логика.
*   **Представление** (View) — отображение данных.
*   **Контроллер** (Controller) — обработка запросов и координация работы модели и представления.

## `ДОП` Зачем нам нужен слой Servise and Repository если модель называется MVC? А не MVCSR! [вопросы](#вопросы)

С ростом сложности приложения, появляется необходимость в дополнительных слоях для **инкапсуляции** определённых задач. **Service** и **Repository** становятся важными для **масштабируемых** и **поддерживаемых** приложений.

## `ДОП` Что такое Servlet? Что такое DispatcherServlet? [вопросы](#вопросы)

**Servlet** — это серверный компонент Java, который обрабатывает HTTP-запросы и генерирует HTTP-ответы.
**DispatcherServlet** — это **основной сервлет** в Spring Framework, который управляет маршрутизацией HTTP-запросов в Spring-приложении. Он действует как **центральный контроллер** (или **front controller**) для всех входящих запросов и направляет их к нужным обработчикам.

#### Как работает DispatcherServlet?

1.  **Принимает запрос** от клиента (например, HTTP GET или POST).
2.  **Определяет, какой контроллер** должен обработать этот запрос с помощью **HandlerMapping**.
3.  **Запускает соответствующий метод контроллера**.
4.  **Получает результат**, который может быть передан в представление.
5.  **Рендерит представление** (например, с помощью **Thymeleaf** или **JSP**) и отправляет ответ клиенту.

## `ДОП` Как контроллер связан c сервлетом? [вопросы](#вопросы)

*   **DispatcherServlet** — это серверный компонент, который маршрутизирует HTTP-запросы.
*   Контроллеры в Spring — это классы, которые обрабатывают эти запросы.
*   **DispatcherServlet** связывает запрос с нужным контроллером с помощью механизма маршрутизации (через аннотации `@RequestMapping`, `@GetMapping` и другие).
*   Контроллеры выполняют бизнес-логику и возвращают ответы, которые **DispatcherServlet** передает пользователю.

### Ключевая идея:

**DispatcherServlet** является основным компонентом в Spring, который выполняет функции сервлета, направляя HTTP-запросы к нужным контроллерам, и фактически связывает контроллеры с сервлетом в контексте Spring MVC.

## 15. Чем контроллер (controller) отличается от сервлета (servlet)? [вопросы](#вопросы)


| **Характеристика** | **Сервлет** | **Контроллер в Spring** |
| --- | --- | --- |
| **Уровень абстракции** | Низкий (работает с HTTP-запросами напрямую) | Высокий (упрощает работу с запросами и представлениями) |
| **Конфигурация маршрутов** | Конфигурируется в `web.xml` или с помощью аннотаций `@WebServlet` | Конфигурируется с помощью аннотаций `@RequestMapping`, `@GetMapping` и других |
| **Ответственность** | Обработка HTTP-запросов, сессий, параметров | Обработка HTTP-запросов и маршрутизация, бизнес-логика, передача данных представлениям |
| **Взаимодействие с Spring** | Не является частью Spring, работает независимо | Часто используется в связке с другими компонентами Spring (например, с сервисами и репозиториями) |
| **Тестируемость** | Сложнее тестировать из-за низкоуровневого взаимодействия с HTTP | Легче тестировать благодаря абстракции и интеграции с Spring Test |
| **Маршрутизация** | Зависит от сервера приложений и конфигурации | Упрощенная маршрутизация через аннотации в Spring |

## 16. Какая основная зависимость фреймворка Spring? Почему во многих сборках она не указывается явно? [вопросы](#вопросы)

Основная зависимость фреймворка **Spring** — это **spring-core**. Это ядро Spring Framework, которое включает базовую функциональность, такую как инверсия управления (IoC), управление бинами, утилиты для работы с коллекциями и другими базовыми задачами.
`Транзитивные зависимости` — это библиотеки или другое программное обеспечение, которое напрямую использует зависимости.
`Maven` или `Gradle`, обрабатывают транзитивные зависимости `автоматически`
В случае с Spring Boot, стартеры (например, spring-boot-starter-web или spring-boot-starter-data-jpa).
Использование стартеров и транзитивных зависимостей позволяет упростить управление версиями и конфигурацией.

## 17. Как вернуть страницу в контроллере? Как вернуть данные? [вопросы](#вопросы)

*   Аннотация `@RestController` автоматически сериализует объекты в JSON, и вам не нужно явно использовать `@ResponseBody`.
*   В примере метод `getData()` возвращает объект `MyData`, который будет автоматически преобразован в JSON.
*   `ResponseEntity.ok(data)` оборачивает данные в объект `ResponseEntity`, который позволяет контролировать статус ответа (например, 200 OK).

### Сравнение: Возврат страницы vs. возврат данных

| **Тип ответа** | **Пример** | **Аннотации** | **Тип возвращаемого объекта** |
| --- | --- | --- | --- |
| **Страница** | Контроллер, который возвращает страницу с данными (например, JSP или HTML) | `@Controller` | String (имя представления) |
| **Данные** | Контроллер, который возвращает данные в формате JSON или XML | `@RestController` или `@ResponseBody` | Объект, который будет сериализован в JSON |

## 18. Уметь рассказать про принципы работы Spring. [вопросы](#вопросы)

- 1\. **Inversion of Control (IoC) — Инверсия управления** - управление созданием объектов и их зависимостями передается контейнеру Spring
- 2\. **Dependency Injection (DI) — Внедрение зависимостей** - Вместо того, чтобы объекты создавали свои зависимости, контейнер Spring внедряет их автоматически.
- 3\. **Aspect-Oriented Programming (AOP) — Ориентированность на аспекты** - AOP позволяет разделять кросс-функциональные задачи (например, логирование, безопасность, транзакции) от основной бизнес-логики. В Spring AOP предоставляет возможность определять "советы" (advice) и "точки соединения" (join points), чтобы добавить дополнительную функциональность в методы классов без изменения их исходного кода.
- 4\. **Loose Coupling (Низкая связь)** - компоненты системы не зависят друг от друга напрямую. Через IoC и DI Spring облегчает создание loosely-coupled.
- 5\. **Declarative Programming (Декларативное программирование)** - В декларативном программировании вы определяете _что_ делать, а не _как_. Spring использует аннотации, такие как `@Transactional`, для декларативного управления транзакциями, а также для других аспектов, таких как кэширование или безопасность, без явной реализации этих механизмов.
- 6\. **Transaction Management (Управление транзакциями)** - процесс контроля за транзакциями базы данных. 
- 7\. **Modularity (Модульность)** - Модульность позволяет разделить приложение на независимые компоненты, Spring Framework состоит из нескольких модулей, таких как Spring Core, Spring MVC, Spring Data, и другие. Каждый из них может быть использован независимо, в зависимости от потребностей приложения.
- 8\. **Convention over Configuration (Конвенция вместо конфигурации)** - система должна обеспечивать разумные умолчания, чтобы минимизировать количество конфигурации, необходимой для работы приложения. В **Spring Boot** это принцип реализуется через автоконфигурацию.
-  9\. **Testability (Тестируемость)** - Легкость тестирования компонентов и приложений. Для тестирования можно использовать фреймворк Spring Test и аннотации, такие как `@SpringBootTest` и `@MockBean`.
- 10\. **Integration (Интеграция)** - Spring предоставляет готовые решения для интеграции с различными технологиями и платформами. базы данных, JMS, веб-сервисы, очереди сообщений и другие.

## 19. Связывание бинов и их жизненный цикл. [вопросы](#вопросы)
 1\. **Создание бина** на основе конфигурации (XML, аннотации, Java-код)
 2\. **Внедрение зависимостей** - DI
 3\. **Инициализация бина** - `init-method` в конфигурации или аннотация `@PostConstruct` будет вызван после внедрения зависимостей
 4\. **Использование бина**
 5\. **Уничтожение бина** - `destroy-method` в конфигурации или аннотация `@PreDestroy` будет вызван перед уничтожением бина.

Жизненные циклы по типу бинов:

1.  **Singleton** - создаётся при старте приложения и используется до его завершения.
2.  **Prototype** - Бины этого типа не управляют своим жизненным циклом, так как Spring создаёт их каждый раз по запросу.
3.  **Request** - один на каждый HTTP-запрос, уничтожается после завершения запроса.
4.  **Session** - Один на каждую HTTP-сессию, уничтожается при завершении сессии.
5.  **GlobalSession** - Один экземпляр на каждую глобальную HTTP-сессию.

## 20. Основные паттерны Spring. [вопросы](#вопросы)

- 1\. **Singleton Pattern** - для класса существует только один экземпляр.
- 2\. **Factory Method Pattern** - позволяет создавать объекты без явного указания конкретного класса.
- 3\. **Observer Pattern** - уведомления объектов об изменениях состояния другого объекта. В Spring этот паттерн реализуется через механизм событий. использование `ApplicationEventPublisher` для публикации событий и `@EventListener` для их обработки.
- 4\. **Template Method Pattern** - предоставляет общий каркас алгоритма, оставляя его конкретные шаги подклассам для реализации.
- 5\. **Proxy Pattern** - для создания объекта-посредника, который управляет доступом к настоящему объекту.
- 6\. **Strategy Pattern** - позволяет выбирать алгоритм выполнения из множества возможных вариантов.
- 7\. **Decorator Pattern** - позволяет добавлять функциональность объектам динамически. добавление новых функциональностей без изменения существующего кода можно реализовать через прокси и аспекты.
- 8\. **Adapter Pattern** - позволяет преобразовывать интерфейсы несовместимых классов, делая их совместимыми. 

## `ДОП` Чем фреймворк отличается от библиотеки? [вопросы](#вопросы)

Фраймворк работает с объектами внутри себя, а библиотека предоставляет методы для обработки.

## `ДОП` Какие есть причины использования Spring? Для чего вообще он нужен? [вопросы](#вопросы)

1. **Инверсия управления (IoC) и внедрение зависимостей (DI)**
2. **Упрощение работы с базами данных**
3. **Модульность**
4. **Spring Boot**
5. **Поддержка аспектно-ориентированного программирования (AOP)**
6. **Тестируемость**
7. **Безопасность**
8. **Сообщество и поддержка**
9. **Универсальность**


## `ДОП` Какой жизненный цикл контейнера Spring? [вопросы](#вопросы)

- 1\. **Запуск контейнера Spring**
- 2\. **Создание бинов**
- 3\. **Инициализация бинов**
- 4\. **Использование контейнера**
- 5\. **Завершение работы контейнера**