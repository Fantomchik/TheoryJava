## Вопросы
- [1. Что такое бин?](#1-что-такое-bean-в-контексте-spring-вопросы)
- [2. Виды бинов?](#2-виды-бинов-вопросы)
- [3. Чем бин отличается от POJO-класса?](#3-чем-бин-отличается-от-pojo-класса-вопросы)
- [4. Что такое Inversion of Control и как Spring реализует этот принцип?](#4-что-такое-inversion-of-control-и-как-spring-реализует-этот-принцип-вопросы)
- - [`ДОП` Какие классы могут быть бинами в Spring?](#доп-какие-классы-могут-быть-бинами-в-спринг-вопросы) 
- - [`ДОП` Как реализован IoC-контейнер? Что за сущность это в Java? (типа массив или что-то ещё)](#доп-как-реализован-ioc-контейнер-что-за-сущность-это-в-java-типа-массив-или-что-то-ещё-вопросы)
- [5. Для чего существует такое количество ApplicationContext?](#5-для-чего-существует-такое-количество-applicationcontext-вопросы)
- [6. Как можно связать бины?](#6-как-можно-связать-бины-вопросы)
- - [`ДОП` MockBean Что это?](#доп-mockbean-что-это-вопросы)
- [7. Что такое Dependency Injection?](#7-что-такое-dependency-injection-вопросы)
- [8. Какие бины будут использоваться для настройки приложения?](#8-какие-бины-будут-использоваться-для-настройки-приложения-вопросы)
- [9. Как получить данные из файла .property?](#9-как-получить-данные-из-файла-property-вопросы)
- [10. Как запустить Спринг-приложение из-под сервера Tomcat?](#10-как-запустить-спринг-приложение-из-под-сервера-tomcat-вопросы)
- [11. Что такое Artifacts?](#11-что-такое-artifacts-вопросы)
- [12. В чем отличие артефакта war от war exploded?](#12-в-чем-отличие-артефакта-war-от-war-exploded-вопросы)
- [13. Какая разница между аннотациями @Component, @Repository и @Service в Spring?](#13-какая-разница-между-аннотациями-component-repository-и-service-в-spring-вопросы)
- [14. Как выглядит структура MVC-приложения?](#14-как-выглядит-структура-mvc-приложения-вопросы)
- - [`ДОП` Зачем нам нужен слой Servise and Repository если модель называется MVC? А не MVCSR!](#доп-зачем-нам-нужен-слой-servise-and-repository-если-модель-называется-mvc-а-не-mvcsr-вопросы)
- - [`ДОП` Что такое Servlet? Что такое DispatcherServlet?](#доп-что-такое-servlet-что-такое-dispatcherservlet-вопросы)
- - [`ДОП` Как контроллер связан c сервлетом?](#доп-как-контроллер-связан-c-сервлетом-вопросы)
- [15. Чем контроллер отличается от сервлета?](#15-чем-контроллер-controller-отличается-от-сервлета-servlet-вопросы)
- [16. Какая основная зависимость фреймворка Спринг? Почему во многих сборках она не указывается явно?](#16-какая-основная-зависимость-фреймворка-spring-почему-во-многих-сборках-она-не-указывается-явно-вопросы)
- [17. Как вернуть страницу в контроллере? Как вернуть данные?](#17-как-вернуть-страницу-в-контроллере-как-вернуть-данные-вопросы)
- [18. Уметь рассказать про принципы работы Spring.](#18-уметь-рассказать-про-принципы-работы-spring-вопросы)
- [19. Связывание бинов и их жизненный цикл.](#19-связывание-бинов-и-их-жизненный-цикл-вопросы)
- [20. Основные паттерны Spring.](#20-основные-паттерны-spring-вопросы)
- - [`ДОП` Чем фреймворк отличается от библиотеки?](#доп-чем-фреймворк-отличается-от-библиотеки-вопросы)
- - [`ДОП` Какие есть причины использования Spring? Для чего вообще он нужен?](#доп-какие-есть-причины-использования-spring-для-чего-вообще-он-нужен-вопросы)
- - [`ДОП` Какой жизненный цикл контейнера Spring?](#доп-какой-жизненный-цикл-контейнера-spring-вопросы)

## 1. Что такое bean в контексте spring? [вопросы](#вопросы)

Bean — это объект, управляемый контейнером Spring. Любой компонент, который Spring создает, настраивает и управляет его жизненным циклом.

## 2. Виды бинов? [вопросы](#вопросы)

✅ **1\. По назначению**
-----------------------

*   **`@Component`** — базовый тип бина. Используется для создания общих компонентов.
*   **`@Service`** — используется для бизнес-логики.
*   **`@Repository`** — используется для взаимодействия с базой данных.
*   **`@Controller`** — используется в Spring MVC для обработки HTTP-запросов.
*   **`@RestController`** — разновидность `@Controller`, которая автоматически сериализует данные в JSON или XML.

✅ **2\. По области видимости (Scope)**
--------------------------------------

Область видимости (`@Scope`) определяет, сколько экземпляров бина будет создано и как долго они будут существовать.

*   **`singleton`** _(по умолчанию)_ — создается один экземпляр на весь контекст Spring.
*   **`prototype`** — создается новый экземпляр при каждом запросе.
*   **`request`** — один экземпляр на HTTP-запрос (только в Spring Web).
*   **`session`** — один экземпляр на сессию пользователя.
*   **`application`** — один экземпляр на всё приложение (аналог Singleton, но для веб-контекста).
*   **`WebSocket`** — один экземпляр bean для каждого WebSocket-соединения(для работы с чатами или потоковыми данными в реальном времени).

✅ **3\. По способу создания**
-----------------------------

*   **Через аннотации** — с использованием `@Component`, `@Service` и других аннотаций.
*   **Через Java-конфигурацию** — с `@Configuration` и `@Bean`.
*   **Через XML-конфигурацию** — если используется старый стиль конфигурации Spring.

✅ **4\. По типу управления**
----------------------------

*   **Managed Beans** — стандартные Spring-бины, созданные и управляемые контейнером Spring.
*   **External Beans** — объекты, созданные вне Spring, но внедрённые в контекст с помощью `@Bean` или `@Configuration`.
*   **Factory Beans** — создаются с использованием `FactoryBean<T>` для более сложных сценариев.

## 3. Чем бин отличается от POJO-класса? [вопросы](#вопросы)

| **Критерий** | **Bean** | **POJO** |
| --- | --- | --- |
| **Определение** | Объект, управляемый контейнером Spring (Spring Bean). | Простая структура данных (Plain Old Java Object). |
| **Управление** | Управляется Spring (жизненный цикл, зависимости). | Не управляется никаким контейнером. |
| **Аннотации** | Использует аннотации: `@Component`, `@Service`, `@Repository`, `@Controller`. | Не требует аннотаций или конфигураций. |
| **Инъекция зависимостей** | Поддерживает внедрение зависимостей через Spring. | Внедрение нужно делать вручную. |
| **Жизненный цикл** | Контейнер контролирует создание, инициализацию и уничтожение. | Жизненный цикл управляется вручную или JVM. |
| **Использование** | Используется в бизнес-логике, сервисах, контроллерах. | Используется как модель данных или DTO. |
| **Примерное поведение** | Может иметь сложную бизнес-логику и зависимости. | Обычно содержит только поля, геттеры, сеттеры. |

все Spring-бины — это POJO, но не все POJO — бины


## 4. Что такое Inversion of Control и как Spring реализует этот принцип? [вопросы](#вопросы)

**Inversion of Control (IoC)** — это принцип, при котором управление созданием и жизненным циклом объектов передаётся внешнему контейнеру или фреймворку. Вместо того чтобы класс самостоятельно создавать свои зависимости с помощью `new`, контейнер предоставляет эти зависимости.

✅ **Как работает IoC в Spring?**
--------------------------------

Spring реализует IoC с помощью **контейнера** Spring, который:

1.  **Создаёт** бины (объекты) на основе конфигурации(XML, java, annotation).
2.  **Управляет** их жизненным циклом.
3.  **Внедряет зависимости** (Dependency Injection)(конструкторы, сеттеры, поля).
4.  **Контролирует** жизненный цикл бинов(`@PostConstruct` и `@PreDestroy`).

## `ДОП` Какие классы могут быть бинами в спринг? [вопросы](#вопросы)

*   Классы с аннотациями `@Component`, `@Service`, `@Repository`, `@Controller`, `@RestController`.
*   Классы, возвращаемые методами с `@Bean`.
*   Фабричные бины с `FactoryBean`.
*   Любые классы, если их создание и управление передано Spring.

## `ДОП` Как реализован IoC-контейнер? Что за сущность это в Java? (типа массив или что-то ещё) [вопросы](#вопросы)

*   Это **объект в памяти**, который содержит бины и управляет ими.
*   Работает как **Map**, где ключ — это имя или тип бина, а значение — сам объект.
*   Может поддерживать сложные зависимости и связывать их между собой.
*   Реализует принципы **Inversion of Control (IoC)** и **Dependency Injection (DI)**.

1.  **`BeanFactory`** — Базовый контейнер, который используется в простых приложениях.
    *   Ленивая инициализация (бин создаётся только при первом запросе).
2.  **`ApplicationContext`** — Более функциональный контейнер, который чаще всего используется.
    *   Поддерживает события, интернационализацию, аннотации и обработчики.
3.  **`AnnotationConfigApplicationContext`** — Контейнер для приложений, сконфигурированных с аннотациями.
4.  **`XmlWebApplicationContext`** — Используется в приложениях с конфигурацией через XML.

## 5. Для чего существует такое количество ApplicationContext? [вопросы](#вопросы)

1.  **Разные источники конфигурации**
    
    *   Конфигурация может быть написана в **Java** (`@Configuration`), в **XML** или быть миксом обоих.
    *   Разные `ApplicationContext` работают с соответствующими источниками данных.
2.  **Среда выполнения**
    
    *   Приложения могут быть **десктопными**, **веб-приложениями** или **микросервисами**.
    *   Есть контейнеры, специально адаптированные для веб-среды (`WebApplicationContext`).
3.  **Управление жизненным циклом**
    
    *   Некоторые контейнеры поддерживают дополнительные функции, такие как обработка веб-запросов или управление сессиями.
4.  **Удобство тестирования**
    
    *   Есть лёгкие контейнеры (`GenericApplicationContext`) для быстрого тестирования.

| **Контекст** | **Описание** | **Когда использовать** |
| --- | --- | --- |
| `AnnotationConfigApplicationContext` | Конфигурация через аннотации `@Configuration`. | При использовании Spring без XML. |
| `ClassPathXmlApplicationContext` | Чтение конфигурации из XML-файлов. | Когда проект уже использует XML или требуется миграция. |
| `FileSystemXmlApplicationContext` | Загружает XML-конфигурацию по пути к файлу. | При конфигурации вне `classpath`. |
| `GenericApplicationContext` | Универсальный контейнер. Поддерживает аннотации и XML. | Для тестов или простых приложений. |
| `AnnotationConfigWebApplicationContext` | Контекст для веб-приложений с аннотациями. | В Spring Boot и Spring MVC. |
| `XmlWebApplicationContext` | Конфигурация веб-приложений через XML. | Для устаревших приложений или тех, что требуют XML. |
| `WebApplicationContext` | Расширение `ApplicationContext` для работы с HTTP-запросами. | Веб-приложения с поддержкой сессий и запросов. |

## 6. Как можно связать бины? [вопросы](#вопросы)

| **Способ** | **Когда использовать** |
| --- | --- |
| `@Autowired` | Когда бин можно однозначно определить. |
| `@Qualifier` | Когда есть несколько реализаций интерфейса. |
| `@Primary` | Если нужно задать бин по умолчанию. |
| Конструкторное связывание | Когда все зависимости обязательны и должны быть `final`(иммутабельными). |
| Сеттерное связывание | Когда зависимость может быть необязательной. |
| Полевая инъекция | Для простоты, но лучше избегать в серьёзных приложениях. |
| `@Bean`\-методы | При необходимости явного контроля за созданием объектов. |
| `@Resource` | из JSR-250 для внедрения по имени. |
| `@Inject` | из JSR-330 работает аналогично @Autowired. |

## `ДОП` MockBean Что это? [вопросы](#вопросы)

`@MockBean` — это аннотация из Spring Boot, которая используется для создания **мока (mock)** с использованием библиотеки **Mockito**. Она чаще всего применяется в **юнит-тестах** или **интеграционных тестах** для подмены реальных бинов мок-объектами.

1.  **`@SpringBootTest`** — Поднимает контекст Spring и тестирует приложение целиком.
2.  **`@MockBean`** — Создаёт мок-объект для `OrderRepository` и регистрирует его в контексте.
3.  **`Mockito.when()`** — Задаёт поведение мок-объекта при вызове метода.
4.  **`Assertions.assertEquals()`** — Проверяет ожидаемый результат.

| **Аспект** | **@MockBean** | **@Mock** |
| --- | --- | --- |
| **Где используется** | В Spring Boot тестах с контекстом (`@SpringBootTest`). | В обычных юнит-тестах без Spring. |
| **Регистрация** | Регистрирует мок в контексте Spring. | Не регистрирует мок в контексте. |
| **Интеграция** | Может заменить реальный бин. | Используется только для Mockito тестов. |
| **Использование** | Для тестов компонентов с зависимостями. | Для изолированных юнит-тестов. |

## 7. Что такое Dependency Injection? [вопросы](#вопросы)

**Dependency Injection (DI)** - это паттерн проектирования, который позволяет управлять зависимостями между объектами и их конфигурацией в приложении. Основная идея `DI` заключается в том, что объекты не создают свои зависимости сами, а получают их извне. Это упрощает тестирование, повышает модульность и делает код более гибким.

В `Spring` это реализовано через `IoC-контейнер`, который управляет жизненным циклом объектов и их зависимостями. Внедряет зависимости через конструкторы, поля и сеттеры. Ищет зависимости по аннотациям **`@Autowired`** **`@Qualifier`** **`@Primary`**  **`@ComponentScan`**.

## 8. Какие бины будут использоваться для настройки приложения? [вопросы](#вопросы)

*   **Конфигурационные классы** (`@Configuration`)
*   **Бины, определённые через `@Bean`**(фабрики)
*   **Настройки через `@Value`(конфигурационных файлов) и `@PropertySource`(внешние файлы)**
*   **Сканирование компонентов** с помощью `@ComponentScan`(в каком пакете искать)
*   **Профили через `@Profile`(для разных сценаривев использования `dev` `prod`)**
*   **Автоматическая настройка в Spring Boot** с `@EnableAutoConfiguration`
*   **Настройки безопасности** через `@EnableWebSecurity`(интеграция кастомных механизмов безопасности(авторизация, аутентификация))
*   **Привязка настроек к POJO с `@ConfigurationProperties`**

## 9. Как получить данные из файла .property? [вопросы](#вопросы)

1.  **Через `@Value`** — для извлечения конкретных значений.
2.  **Через `@ConfigurationProperties`** — для привязки всех настроек в объект POJO.
3.  **Через `@PropertySource`** — если файл `.properties` не является стандартным `application.properties` и находится в другом месте.
4.  **Использование `Environment` для доступа к свойствам** - объект, хронящий в себе настройки.

## 10. Как запустить Спринг-приложение из-под сервера Tomcat? [вопросы](#вопросы)

**1\. Добавить maven-war-plugin**
**2\.Создание конфигурационного файла web.xml (если не используете Spring Boot)**
**3\.Сборка WAR-файла**
**4\.Развертывание на Tomcat**
**5\.Запуск Tomcat**
**6\.Доступ к приложению**

## 11. Что такое Artifacts? [вопросы](#вопросы)

**artifact** обозначает результат процесса разработки. 

1. **Исполняемые файлы** - **JAR** (Java ARchive), **WAR** (Web ARchive), **EAR** (Enterprise ARchive), содержащие скомпилированный код.
2. **Библиотеки**  
3. **Ресурсы** - конфиг, изо, доки, кот необходими апликации.
4. **Документация** - например Javadoc
5. **Скрипты** - для развёртывания, миграции данных или тестов.

Артефакты могут быть созданы при сборке, тестировании, развёртывании. 

## 12. В чем отличие артефакта war от war exploded? [вопросы](#вопросы)

| Характеристика | **WAR** | **WAR Exploded** |
| --- | --- | --- |
| **Формат** | Архивированный (файл .war) | Развернутая структура папок и файлов |
| **Использование** | Подходит для продакшн развертывания | Удобен для разработки и тестирования |
| **Процесс развертывания** | Требуется распаковка на сервере | Сервер может работать с развернутыми файлами напрямую |
| **Отслеживание изменений** | Нужно пересоздавать архив при изменении | Изменения видны сразу, не требуется перезапуск сервера |
| **Размер** | Обычно меньше, чем WAR Exploded | Может быть больше из-за наличия всех файлов без сжатия |

## 13. Какая разница между аннотациями @Component, @Repository и @Service в Spring? [вопросы](#вопросы)

| Аннотация | Описание | Пример использования | Когда использовать |
| --- | --- | --- | --- |
| **`@Component`** | Общая аннотация для компонента | Вспомогательные классы | Когда класс не попадает под специфические категории, например, утилиты. |
| **`@Repository`** | Добавляет поддержку обработки исключений базы данных | Репозитории, DAO, JPA, Hibernate | Для классов, осуществляющих доступ к данным, работы с базой данных. |
| **`@Service`** | Аннотация для бизнес-слоя, предоставляющего сервисы | Логика бизнес-сервисов | Для сервисов, содержащих бизнес-логику, которая обрабатывает данные. |

## 14. Как выглядит структура MVC-приложения? [вопросы](#вопросы)

*   **Модель** (Model) — данные и бизнес-логика.
*   **Представление** (View) — отображение данных.
*   **Контроллер** (Controller) — обработка запросов и координация работы модели и представления.

## `ДОП` Зачем нам нужен слой Servise and Repository если модель называется MVC? А не MVCSR! [вопросы](#вопросы)

С ростом сложности приложения, появляется необходимость в дополнительных слоях для **инкапсуляции** определённых задач. **Service** и **Repository** становятся важными для **масштабируемых** и **поддерживаемых** приложений.

## `ДОП` Что такое Servlet? Что такое DispatcherServlet? [вопросы](#вопросы)

**Servlet** — это серверный компонент Java, который обрабатывает HTTP-запросы и генерирует HTTP-ответы.
**DispatcherServlet** — это **основной сервлет** в Spring Framework, который управляет маршрутизацией HTTP-запросов в Spring-приложении. Он действует как **центральный контроллер** (или **front controller**) для всех входящих запросов и направляет их к нужным обработчикам.

#### Как работает DispatcherServlet?

1.  **Принимает запрос** от клиента (например, HTTP GET или POST).
2.  **Определяет, какой контроллер** должен обработать этот запрос с помощью **HandlerMapping**.
3.  **Запускает соответствующий метод контроллера**.
4.  **Получает результат**, который может быть передан в представление.
5.  **Рендерит представление** (например, с помощью **Thymeleaf** или **JSP**) и отправляет ответ клиенту.

## `ДОП` Как контроллер связан c сервлетом? [вопросы](#вопросы)

