## Вопросы
- [1. Что такое generic и для чего они нужны?](#1-что-такое-generic-и-для-чего-они-нужны-вопросы)
- [2. Зачем вообще ввели дженерики? Как до дженериков программировали?](#2-зачем-вообще-ввели-дженерики-как-до-дженериков-программировали-вопросы)
- [3. Что можно параметризовать?](#3-что-можно-параметризовать-вопросы)
- [4. Как параметризовать статический метод?](#4-как-параметризовать-статический-метод-вопросы)
- [5. Что такое raw type? К чему приводит использование raw type?](#5-что-такое-raw-type-к-чему-приводит-использование-raw-type-вопросы)
- [6. Если поле типизировано дженериком как в байт коде будет представлен этот тип?](#6-если-поле-типизировано-дженериком-как-в-байт-коде-будет-представлен-этот-тип-вопросы)
- [7. Что такое даймонд оператор?](#7-что-такое-даймонд-оператор-вопросы)
- [8. Что такое wildcard?](#8-что-такое-wildcard-вопросы)
- [9. Расскажи про иерархию коллекций?](#9-расскажи-про-иерархию-коллекций-вопросы)
- [10. Расскажи отличие List от Set?](#10-расскажи-отличие-list-от-set-вопросы)
- [11. Расскажи отличие ArrayList от LinkedList?](#11-расскажи-отличие-arraylist-от-linkedlist-вопросы)
- [12. Когда лучше использовать ArrayList, а когда LinkedList?](#12-когда-лучше-использовать-arraylist-а-когда-linkedlist-вопросы)
- [13. В чём разница между Queue и Deque и Stack?](#13-в-чём-разница-между-queue-и-deque-и-stack-вопросы)
- [14. Отличие двусвязного и односвязного списка?](#14-отличие-двусвязного-и-односвязного-списка-вопросы)
- [15. Как работает HashSet?](#15-как-работает-hashset-вопросы)
- [16. Как работает метод contains в ArrayList, LinkedList, HashSet?](#16-как-работает-метод-contains-в-arraylist-linkedlist-hashset-вопросы)
- [17. В чём разница между Iterable и Iterator?](#17-в-чём-разница-между-iterable-и-iterator-вопросы)
- [18. Что такое Iterator?](#18-что-такое-iterator-вопросы)
- [19. В каких случаях нужно использовать iterator? И почему?](#19-в-каких-случаях-нужно-использовать-iterator-и-почему-вопросы)
- [20. Что такое Map? Что должно быть уникальным?](#20-что-такое-map-что-должно-быть-уникальным-вопросы)
- [21. Может ли null быть ключём в HashMap?](#21-может-ли-null-быть-ключём-в-hashmap-вопросы)
- [22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии?](#22-как-работает-hashmap-расскажите-подробно-как-работает-метод-put-что-происходит-при-коллизии-вопросы)
- [23. Как работает метод get в HashMap?](#23-как-работает-метод-get-в-hashmap-вопросы)

## 1. Что такое generic и для чего они нужны? [вопросы](#вопросы)


**Generic (обобщения)** — это механизм в Java, который позволяет создавать классы, интерфейсы и методы, работающие с различными типами данных, при этом тип данных передается как параметр. Это даёт возможность создавать универсальные компоненты, которые могут работать с любыми типами данных без потери типовой безопасности.

### Зачем они нужны:

1.  **Типовая безопасность:** Обобщения позволяют избежать ошибок типов, которые могут возникнуть, если вы работаете с коллекциями без уточнения типа. Например, в старых версиях Java для работы с коллекциями часто использовались типы `Object`, что приводило к необходимости явных преобразований типов (casting). Обобщения решают эту проблему, обеспечивая безопасность типов на этапе компиляции.
    
2.  **Переиспользуемость кода:** Вместо того чтобы создавать отдельные классы или методы для разных типов, можно использовать один универсальный класс или метод, который будет работать с любым типом данных.
    
3.  **Читаемость и поддерживаемость кода:** Код, использующий обобщения, проще читать и поддерживать, поскольку отсутствуют явные приведения типов, и легче понять, с какими типами данных работает ваш код.
    

### Пример использования generic:

```java
// Пример generic-класса
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<Integer> intBox = new Box<>();
        intBox.setValue(42);
        System.out.println(intBox.getValue());  // 42

        Box<String> strBox = new Box<>();
        strBox.setValue("Hello");
        System.out.println(strBox.getValue());  // Hello
    }
}
```

В этом примере `Box<T>` — это обобщенный класс, где `T` может быть любым типом (например, `Integer`, `String` и т.д.). Мы создаем объект типа `Box<Integer>` и `Box<String>`, и метод `setValue` принимает значения соответствующих типов.

### Обобщения можно использовать:

*   Для создания универсальных коллекций, таких как `List<T>`, `Map<K, V>`.
*   Для создания обобщённых методов.
*   Для создания обобщённых интерфейсов и классов.

Таким образом, **generic** делает ваш код гибким, безопасным и удобным для использования с любыми типами данных.

## 2. Зачем вообще ввели дженерики? Как до дженериков программировали? [вопросы](#вопросы)
 

**Зачем ввели дженерики?**

Дженерики были введены в Java с релизом J2SE 5.0 (в 2004 году) для решения нескольких проблем, которые возникали при разработке программ до их появления:

1.  **Проблемы с типовой безопасностью:**  
    До появления дженериков многие коллекции и структуры данных работали с объектами типа `Object`. Это означало, что при добавлении объектов в коллекции не было проверки их типов на этапе компиляции, что приводило к ошибкам во время выполнения. Например, можно было добавить объект неправильного типа в коллекцию, и это приводило к исключению `ClassCastException` при попытке извлечь объект из коллекции.
    
    Пример без дженериков:
    
    ```java
    List list = new ArrayList();
    list.add("Hello");
    list.add(123); // добавили объект другого типа
    
    String str = (String) list.get(1); // Ошибка времени выполнения: ClassCastException
    ```
    
    С введением дженериков компилятор проверяет типы на этапе компиляции, что исключает такие ошибки.
    
2.  **Нехватка универсальных и переиспользуемых компонентов:**  
    Без дженериков программисты часто были вынуждены создавать отдельные классы для работы с разными типами данных, что приводило к большому количеству дублирующегося кода. Дженерики позволяют создать универсальные компоненты, которые могут работать с различными типами данных без дублирования кода.
    
    Пример без дженериков:
    
    ```java
    public class IntegerBox {
        private Integer value;
        public void setValue(Integer value) { this.value = value; }
        public Integer getValue() { return value; }
    }
    
    public class StringBox {
        private String value;
        public void setValue(String value) { this.value = value; }
        public String getValue() { return value; }
    }
    ```
    
    С дженериками можно обрабатывать любые типы одним универсальным классом.
    
    Пример с дженериками:
    
    ```java
    public class Box<T> {
        private T value;
        public void setValue(T value) { this.value = value; }
        public T getValue() { return value; }
    }
    ```
    
3.  **Упрощение и повышение читаемости кода:**  
    Программисты, использующие старые коллекции без дженериков, часто добавляли комментарии или использовали дополнительные проверки типов, чтобы убедиться, что работает с нужными объектами. Это снижало читаемость и добавляло лишний код. Дженерики делают код более чистым, понятным и безопасным.
    

* * *

**Как программировали до дженериков?**

До введения дженериков в Java программы часто использовали тип `Object` для работы с коллекциями и другими структурами данных. Все объекты в Java являются наследниками класса `Object`, поэтому было возможно работать с любыми типами данных через ссылки на `Object`. Однако это приводило к нескольким проблемам:

1.  **Необходимость явного приведения типов (casting):** Поскольку коллекции принимали объекты типа `Object`, при извлечении данных из коллекции необходимо было делать явное преобразование типов. Это было неудобно и часто приводило к ошибкам, так как компилятор не мог гарантировать, что извлечённый объект соответствует нужному типу.
    
    Пример:
    
    ```java
    List list = new ArrayList();
    list.add("Hello");
    list.add(42);
    
    String str = (String) list.get(0);  // Преобразование типов
    Integer num = (Integer) list.get(1); // Преобразование типов
    ```
    
    Преобразование могло быть неудачным, если типы не совпадали, что приводило к исключениям.
    
2.  **Отсутствие проверки типов на этапе компиляции:** Программисты не могли полагаться на компилятор для проверки типов, а все ошибки проверялись только на этапе выполнения. Это усложняло разработку, потому что ошибки типов могли быть обнаружены только во время выполнения, что делало процесс отладки сложным.
    
3.  **Дублирование кода:** Если необходимо было создать несколько классов или методов для работы с разными типами данных, это приводило к большому количеству повторяющегося кода. Например, для работы с разными типами значений (например, строками, числами и т.д.) приходилось писать отдельные классы и методы для каждого типа.
    
4.  **Необходимость дополнительных проверок и обработчиков ошибок:**  
    Для того чтобы избежать ошибок типов, программисты часто писали дополнительные проверки, чтобы удостовериться, что объекты имеют нужный тип. Это добавляло сложности и снижало производительность кода.
    

* * *

**Введение дженериков** решило эти проблемы, сделав код безопасным, универсальным и более читаемым.

## 3. Что можно параметризовать? [вопросы](#вопросы)


В Java с помощью **дженериков** можно параметризовать следующие элементы:

### 1\. **Классы**

Вы можете создать обобщённый класс, который работает с различными типами данных. Тип данных передаётся в качестве параметра при создании объекта этого класса.

Пример:

```java
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

В данном примере тип `T` параметризует класс `Box`, и тип `T` можно выбрать при создании объекта этого класса (например, `Box<Integer>`, `Box<String>`).

### 2\. **Интерфейсы**

Вы можете создавать обобщённые интерфейсы, которые работают с различными типами. Также тип данных передаётся как параметр при реализации интерфейса.

Пример:

```java
public interface Storage<T> {
    void add(T item);
    T get();
}

public class StringStorage implements Storage<String> {
    private String value;

    @Override
    public void add(String item) {
        value = item;
    }

    @Override
    public String get() {
        return value;
    }
}
```

В этом примере интерфейс `Storage<T>` обрабатывает элементы любого типа, а класс `StringStorage` реализует его для типа `String`.

### 3\. **Методы**

Методы могут быть параметризованы типами, что позволяет использовать дженерики в методах внутри классов. Это особенно полезно, если вы хотите, чтобы метод работал с разными типами данных.

Пример:

```java
public class Util {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }
}
```

Метод `printArray` параметризован типом `T`, что позволяет передавать ему массивы любых типов, например, `Integer[]`, `String[]`, и так далее.

### 4\. **Конструкторы**

Можно также параметризовать типы в конструкторах. Однако в отличие от методов и классов, параметризованные типы обычно не могут быть использованы в качестве параметров конструктора непосредственно. Вместо этого конструктор будет ссылаться на дженерик-класс или дженерик-метод.

Пример:

```java
public class Pair<T, U> {
    private T first;
    private U second;

    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public U getSecond() {
        return second;
    }
}
```

В этом примере класс `Pair` параметризован двумя типами `T` и `U`, и конструктор использует эти типы для инициализации полей объекта.

### 5\. **Типы параметров коллекций (Коллекции с дженериками)**

Одной из наиболее распространённых областей применения дженериков является работа с коллекциями, такими как `List`, `Set`, `Map`. В коллекциях можно указать конкретные типы элементов, с которыми они будут работать.

Пример:

```java
List<String> list = new ArrayList<>();
list.add("Hello");
list.add("World");

String s = list.get(0); // безопасно, без явного приведения типа
```

В коллекции `List<String>` хранится только строки, и тип проверяется на этапе компиляции.

### 6\. **Типы исключений (generic исключения)**

В Java нельзя параметризовать сами классы исключений (например, `Exception<T>`), но можно параметризовать методы, которые выбрасывают исключения с определёнными типами.

Пример:

```java
public class MyException<T> extends Exception {
    private T errorDetail;

    public MyException(T errorDetail) {
        this.errorDetail = errorDetail;
    }

    public T getErrorDetail() {
        return errorDetail;
    }
}
```

Здесь класс `MyException` параметризован типом `T`, который можно использовать для хранения дополнительной информации об ошибке.

### 7\. **Типы в параметрах (Wildcard)**

Можно использовать так называемые **подстановочные знаки** (wildcards) в дженериках. Это позволяет параметризовать типы с некоторыми ограничениями, например, обозначать любой тип, который является наследником другого.

Пример:

```java
public static void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

Здесь `?` обозначает любой тип, и метод может принимать список любых объектов.

Вы можете также ограничивать подстановочный знак:

```java
public static void printNumbers(List<? extends Number> list) {
    for (Number num : list) {
        System.out.println(num);
    }
}
```

Этот метод примет список, который может содержать любые типы, являющиеся подклассами `Number` (например, `Integer`, `Double`).

* * *

### Заключение

С помощью дженериков можно параметризовать:

*   **Классы**
*   **Интерфейсы**
*   **Методы**
*   **Конструкторы**
*   **Коллекции**
*   **Типы исключений**
*   **Подстановочные знаки**

Это даёт возможность создавать гибкие и безопасные компоненты, которые могут работать с любыми типами данных, сохраняя при этом преимущества типовой безопасности и переиспользуемости кода.

## 4. Как параметризовать статический метод? [вопросы](#вопросы)


Параметризовать **статический метод** с помощью **дженериков** можно так же, как и обычный метод. Разница заключается в том, что статические методы принадлежат классу, а не экземпляру класса, поэтому параметры типа (`<T>`) необходимо указать непосредственно в объявлении метода.

Вот пример того, как это делается:

### Пример: Параметризация статического метода

```java
public class Utility {
    // Статический обобщённый метод
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        // Вызов статического обобщённого метода с массивом типа Integer
        Integer[] intArray = {1, 2, 3, 4, 5};
        Utility.printArray(intArray);

        // Вызов статического обобщённого метода с массивом типа String
        String[] strArray = {"Hello", "World"};
        Utility.printArray(strArray);
    }
}
```

### Объяснение:

1.  В методе `printArray` параметризованный тип `T` указывается в самом начале метода (до возвращаемого типа) как `<T>`. Это означает, что метод может работать с массивом любого типа.
2.  В методе `main` вызываются два экземпляра этого статического метода: один с массивом `Integer[]`, а другой — с массивом `String[]`. Компилятор автоматически подставляет соответствующие типы в момент вызова метода.

### Статический метод с несколькими параметрами типов

Если необходимо параметризовать метод с несколькими типами, это тоже возможно. Например:

```java
public class Utility {
    // Статический метод с двумя параметрами типов
    public static <T, U> void printPair(T first, U second) {
        System.out.println("First: " + first);
        System.out.println("Second: " + second);
    }

    public static void main(String[] args) {
        // Вызов с различными типами
        Utility.printPair(42, "Hello");
        Utility.printPair(3.14, true);
    }
}
```

### Объяснение:

В этом примере метод `printPair` параметризован двумя типами: `T` и `U`. Он может принимать два значения разных типов, и это будет проверяться на этапе компиляции. В методе `main` показаны два вызова с разными типами аргументов.

### Заключение:

Чтобы параметризовать **статический метод**, нужно указать типы в декларации метода так же, как и для обычного метода, перед возвращаемым типом, используя конструкцию `<T>`. Статический метод будет работать с типами, которые передаются ему при вызове.

## 5. Что такое raw type? К чему приводит использование raw type? [вопросы](#вопросы)


**Raw type** (сырой тип) в Java — это использование обобщённого типа без указания параметров типа. То есть, это использование **дженериков** без явного указания типа, с которым они должны работать. В этом случае компилятор воспринимает обобщённый тип как **непараметризованный** и считает его типом `Object`.

### Пример использования raw type:

```java
List list = new ArrayList(); // raw type
list.add("Hello");
list.add(42);

String str = (String) list.get(0); // Это безопасно
Integer num = (Integer) list.get(1); // Это приведет к ошибке во время выполнения
```

Здесь `List` используется без параметра типа, что делает его **сырой коллекцией**. Таким образом, это значит, что в список можно добавить объекты любого типа, и компилятор не будет проверять типы на этапе компиляции.

### К чему приводит использование raw type?

Использование **raw type** может привести к нескольким проблемам:

1.  **Отсутствие проверки типов на этапе компиляции:** При использовании сырого типа компилятор не проверяет типы данных, что может привести к ошибкам на этапе выполнения. Например, можно добавить элемент неподходящего типа в коллекцию и столкнуться с ошибками при извлечении элементов.
    
    В примере выше, `list.add(42)` добавляет `Integer`, а `list.add("Hello")` — строку. Когда вы пытаетесь извлечь элементы, они приводятся к неправильным типам, что приведёт к `ClassCastException`:
    
    ```java
    String str = (String) list.get(0);  // Работает, потому что это String
    Integer num = (Integer) list.get(1); // Приведёт к ClassCastException
    ```
    
2.  **Проблемы с типовой безопасностью:** Без параметров типа невозможно гарантировать, что коллекция или объект будет содержать только элементы определённого типа. Это нарушает типовую безопасность, которая является одной из главных целей использования дженериков.
    
3.  **Уменьшение читаемости и поддерживаемости кода:** Когда используется raw type, становится неясно, с какими типами данных работает коллекция или метод. Например, если бы в примере выше использовался `List<String>`, было бы сразу понятно, что список предназначен для строк. Без параметра типа это не очевидно.
    
4.  **Потеря преимуществ дженериков:** Дженерики позволяют создавать универсальные, типобезопасные компоненты. Использование raw type отменяет эти преимущества. Вы теряете возможность компилятора проверять типы, а также возможность использовать ограничения на типы данных (например, `List<? extends Number>`).
    

### Почему raw type всё ещё существует?

Raw type был введён в Java до появления дженериков в версии 5.0. Когда дженерики были добавлены, Java оставила совместимость с предыдущими версиями, чтобы старый код, использующий raw type, продолжал работать. Таким образом, raw type позволяет работать с кодом, который использует старые коллекции и классы, созданные до введения дженериков.

### Как избежать использования raw type?

Чтобы избежать проблем с типами, рекомендуется всегда использовать обобщённые типы. Например:

```java
// Правильный способ использования коллекции с дженериками:
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(42);  // Ошибка компиляции

String str = list.get(0);  // Безопасно
```

Если вам нужно работать с обобщёнными типами, используйте дженерики и явно указывайте типы данных, чтобы обеспечить безопасность и читаемость кода.

### Заключение

Использование **raw type**:

*   Отключает проверку типов на этапе компиляции.
*   Может привести к исключениям времени выполнения.
*   Нарушает типовую безопасность.
*   Уменьшает читаемость и поддерживаемость кода.

Чтобы избежать этих проблем, всегда используйте **параметризованные типы** и **дженерики**, которые позволяют компилятору проверять типы на этапе компиляции и обеспечивают типовую безопасность.

## 6. Если поле типизировано дженериком как в байт коде будет представлен этот тип? [вопросы](#вопросы)


Когда в **байт-коде** используется **дженерик** (обобщённый тип), **Java** выполняет **стирание типов** (type erasure), то есть **удаляет** информацию о параметризированных типах на момент компиляции, чтобы обеспечить совместимость с более старыми версиями Java, которые не поддерживают дженерики.

В результате этого механизма, все дженерики в исходном коде преобразуются в **raw types** (сырой тип), а типы параметров **игнорируются** в байт-коде. Всё это приводит к тому, что в байт-коде **нет информации о параметризованных типах**. Вместо этого, все параметры типов заменяются на их **ограничения** или на `Object`, если ограничение не задано.

### Как это работает?

1.  **Удаление информации о типах**: Все обобщённые типы в Java стираются, и вместо них в байт-коде остаются только их **raw types**. Например, если у вас есть класс с параметризированным типом, компилятор заменяет его на **raw type**.
    
2.  **Использование ограничений**: Если в дженерике задано ограничение (например, `T extends Number`), то в байт-коде параметр типа будет заменён на это ограничение. Например, для `List<T extends Number>` в байт-коде будет представлен тип `List<Number>`.
    
3.  **Преобразование методов**: Методы, использующие дженерики, также будут иметь стирание типов. Типы параметров методов и возвращаемые значения будут заменяться на типы, определённые в результате стирания.
    

### Пример:

Возьмём следующий код:

```java
public class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```

В этом примере `Box` — это обобщённый класс с типом `T`, который используется для хранения значения.

После компиляции в **байт-коде** тип `T` будет **стерён**, и класс будет выглядеть следующим образом:

```java
public class Box {
    private Object value;

    public void setValue(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}
```

Как видно:

*   Поле `value`, которое было типизировано как `T`, теперь будет типизировано как `Object` в байт-коде.
*   Методы `setValue` и `getValue` будут работать с типом `Object`, а не с конкретным типом `T`, потому что Java не сохраняет информацию о типах после компиляции.

### Как это влияет на работу программы:

1.  **Типы стираются, но безопасность сохраняется на уровне компиляции**: В исходном коде Java можно использовать конкретные типы, и компилятор проверит типы данных на этапе компиляции. Однако, после компиляции типы будут стерты, и код будет работать с **raw types**. На этапе компиляции вся проверка типов осуществляется, чтобы исключить ошибки типов, но во время выполнения Java будет работать с raw types (например, `Object`).
    
2.  **Типовые ограничения**: Если дженерик имеет ограничение, например, `T extends Number`, то в байт-коде будет заменён тип `T` на `Number`.
    
    Пример:
    
    ```java
    public class Box<T extends Number> {
        private T value;
    
        public void setValue(T value) {
            this.value = value;
        }
    
        public T getValue() {
            return value;
        }
    }
    ```
    
    После стирания тип `T` будет заменён на `Number`:
    
    ```java
    public class Box {
        private Number value;
    
        public void setValue(Number value) {
            this.value = value;
        }
    
        public Number getValue() {
            return value;
        }
    }
    ```
    

### Стирка типов и подстановочные знаки (`wildcards`)

Когда используется подстановочный знак, например, `List<?>`, это также стирается в байт-коде, и заменяется на **raw type**. Например, `List<?>` будет восприниматься как `List` в байт-коде, что является raw type, и не будет связано с конкретным типом.

### Заключение

В **байт-коде** информация о типах, использующих **дженерики**, **стерта** (type erasure), и заменена на **raw types** или на типы, указанные в ограничениях (например, `Object`, если ограничение не указано). Это делает байт-код более совместимым с предыдущими версиями Java, которые не поддерживали дженерики.

## 7. Что такое даймонд оператор? [вопросы](#вопросы)


**Даймонд-оператор** (diamond operator) — это специальный синтаксический элемент, который был введён в **Java 7** для улучшения читаемости и уменьшения дублирования кода при создании объектов с дженериками. Он позволяет компилятору автоматически выводить типы дженериков на основе контекста, избавляя от необходимости повторно указывать тип при создании объекта.

### Пример без даймонд-оператора:

До Java 7, при создании экземпляров классов с дженериками, нужно было явным образом указывать тип как в левой, так и в правой части объявления:

```java
List<String> list = new ArrayList<String>();
```

Здесь, и в левой, и в правой частях кода, явно указывается тип `String`, что делает код избыточным.

### Пример с даймонд-оператором:

С **Java 7** можно использовать **даймонд-оператор** `< >`, чтобы компилятор сам выводил тип на основе контекста:

```java
List<String> list = new ArrayList<>();
```

Здесь `<>` (даймонд-оператор) заменяет явное указание типа в правой части, и компилятор сам определяет, что типом для `ArrayList` должен быть `String`, так как он указан в левой части.

### Как работает даймонд-оператор?

1.  **Вывод типа**: Компилятор автоматически выводит тип дженерика, основываясь на типе, который указан в переменной слева от оператора. Это позволяет избежать повторения и сделать код более чистым.
    
2.  **Снижение избыточности**: Применение даймонд-оператора помогает избавиться от дублирования типов в коде, что особенно полезно при создании сложных объектов с множеством дженериков.
    

### Пример:

```java
// Без даймонд-оператора
Map<String, List<Integer>> map = new HashMap<String, List<Integer>>();

// С даймонд-оператором
Map<String, List<Integer>> map = new HashMap<>();  // Компилятор сам определит типы
```

В примере выше компилятор сам определяет типы `String` и `List<Integer>`, исходя из того, что в переменной `map` указаны эти типы.

### Ограничения:

1.  **Не работает с анонимными классами**: Если создаётся анонимный класс, дженерики должны быть указаны вручную, так как компилятор не может вывести типы для анонимных классов.
    
    Пример:
    
    ```java
    // Неверно, компилятор не может вывести типы для анонимного класса
    List<String> list = new List<>() {
        @Override
        public boolean add(String e) {
            return super.add(e);
        }
    };
    ```
    
2.  **Только для правой части**: Даймонд-оператор можно использовать только при создании объектов, а не при объявлении переменных. То есть, левая часть (переменная) всё равно должна быть полностью типизирована.
    
    Пример:
    
    ```java
    // Правильно
    List<String> list = new ArrayList<>();
    
    // Неверно
    var list = new ArrayList<>();  // Ошибка, компилятор не может вывести тип для переменной
    ```
    

### Заключение:

**Даймонд-оператор** позволяет уменьшить дублирование типов при создании объектов с дженериками, делая код более читаемым и компактным. Он помогает компилятору автоматически выводить типы на основе контекста, устраняя необходимость явно указывать их дважды.

## 8. Что такое wildcard? [вопросы](#вопросы)


**Wildcard** (подстановочный знак) в **Java** — это специальный механизм, который позволяет работать с обобщёнными типами (дженериками), не уточняя конкретный тип данных. Wildcard используется для обозначения "неопределённого" типа и позволяет параметризовать коллекции или другие типы данных без указания точного типа.

### Основные виды Wildcard

1.  **`?` — неограниченный wildcard**: Это самый простой и общий wildcard, который представляет любой тип.
    
    Пример:
    
    ```java
    List<?> list = new ArrayList<String>();  // Лист может содержать элементы любого типа
    ```
    
    В этом примере `?` заменяет конкретный тип (например, `String` или `Integer`), и метод может работать с любым типом. Однако, при использовании этого wildcard, не получится добавлять элементы в коллекцию (кроме `null`), так как компилятор не знает, с каким типом работает коллекция.
    
2.  **`? extends T` — wildcard с верхним ограничением**: Этот wildcard ограничивает типы теми, которые являются подтипами или самими собой типа `T`. Это полезно, когда нужно указать, что коллекция может содержать элементы определённого типа или его подтипы.
    
    Пример:
    
    ```java
    List<? extends Number> list = new ArrayList<Integer>();
    ```
    
    В этом примере `? extends Number` означает, что коллекция может содержать объекты типа `Number` или его подтипов, таких как `Integer`, `Double` и т.д.
    
    Использование `? extends T` позволяет безопасно читать из коллекции (все элементы будут типа `T` или подтипами), но не позволяет добавлять элементы в коллекцию (кроме `null`), так как мы не знаем точного типа элементов.
    
    Пример с чтением:
    
    ```java
    List<? extends Number> list = new ArrayList<Integer>();
    Number number = list.get(0);  // Всё в порядке, так как все элементы — это Number или его подтипы
    ```
    
3.  **`? super T` — wildcard с нижним ограничением**: Этот wildcard ограничивает типы такими, которые являются суперклассами или самими собой типа `T`. Это полезно, когда нужно указать, что коллекция может содержать элементы типа `T` или его суперклассов.
    
    Пример:
    
    ```java
    List<? super Integer> list = new ArrayList<Number>();
    ```
    
    В этом примере `? super Integer` означает, что коллекция может содержать объекты типа `Integer` или его суперклассов, таких как `Number` или `Object`.
    
    Использование `? super T` позволяет безопасно добавлять элементы в коллекцию, так как мы точно знаем, что в коллекции могут быть элементы типа `T` или более общие типы.
    
    Пример с добавлением:
    
    ```java
    List<? super Integer> list = new ArrayList<Number>();
    list.add(42);  // Всё в порядке, так как Integer является подтипом Number
    ```
    

### Примеры использования Wildcard:

1.  **Чтение и добавление с `? extends T`**:
    
    ```java
    public static void printNumbers(List<? extends Number> list) {
        for (Number num : list) {
            System.out.println(num);
        }
    }
    ```
    
    В этом примере мы можем передать любой список, содержащий объекты типа `Number` или его подтипы, например, `List<Integer>`, `List<Double>`, и т. д.
    
2.  **Чтение и добавление с `? super T`**:
    
    ```java
    public static void addIntegers(List<? super Integer> list) {
        list.add(42);  // Мы знаем, что в коллекции могут быть Integer или его суперклассы
    }
    ```
    
    В этом примере мы можем передать любой список, который может содержать объекты типа `Integer` или его суперклассы (например, `List<Number>`, `List<Object>` и т. д.).
    

### Почему важно использовать Wildcard?

1.  **Гибкость**: Wildcards позволяют писать более универсальные и гибкие методы, которые могут работать с коллекциями разных типов, не уточняя их в явном виде.
    
2.  **Типовая безопасность**: Wildcards сохраняют типовую безопасность при работе с обобщёнными типами. Например, использование `? extends Number` гарантирует, что коллекция будет содержать объекты типа `Number` или его подтипы, что предотвращает ошибки типов.
    
3.  **Реализация методов с обобщёнными типами**: Когда вы хотите создать метод, который может принимать коллекции разных типов, wildcard поможет избежать избыточности и упростит код.
    

### Заключение

**Wildcard** в Java — это инструмент для работы с обобщёнными типами, который позволяет более гибко работать с коллекциями и другими параметризированными типами. Он помогает указать "неопределённые" типы или же типы с ограничениями, что повышает гибкость и типовую безопасность кода.

## 9. Расскажи про иерархию коллекций? [вопросы](#вопросы)


В **Java** коллекции — это структуры данных, которые предоставляют способы хранения и управления группами объектов. Все коллекции в Java являются частью пакета `java.util` и следуют строгой иерархии, основанной на интерфейсах и классах. Эта иерархия предоставляет гибкость для различных типов коллекций, таких как списки, множества и карты.

### Иерархия коллекций в Java

Основная иерархия коллекций в Java состоит из нескольких ключевых интерфейсов, которые являются родительскими для более специализированных коллекций. Давайте рассмотрим основные элементы этой иерархии.

* * *

### 1\. **Collection (Интерфейс)**

**`Collection`** — это корневой интерфейс для большинства коллекций в Java. Он определяет базовые методы для всех коллекций, такие как добавление, удаление элементов, проверка на наличие элементов и т. д. Однако сам по себе этот интерфейс не может быть использован напрямую для создания коллекций.

Методы `Collection`:

*   `add()`, `remove()`, `size()`, `contains()`, `clear()`, `isEmpty()` и другие.

#### Основные подинтерфейсы:

*   **List**
*   **Set**
*   **Queue**
*   **Deque**

### 2\. **List (Интерфейс)**

**`List`** — это подинтерфейс `Collection`, который представляет коллекцию с элементами, упорядоченными по индексу. В коллекции `List` можно иметь дубликаты элементов, и они хранятся в том порядке, в котором были добавлены.

Методы `List`:

*   `get(int index)`: возвращает элемент по индексу.
*   `add(int index, E element)`: добавляет элемент по указанному индексу.
*   `set(int index, E element)`: заменяет элемент по индексу.
*   `remove(int index)`: удаляет элемент по индексу.

#### Реализации:

*   **ArrayList** — динамический массив.
*   **LinkedList** — двусвязный список.
*   **Vector** — устаревшая реализация, похожая на `ArrayList`.

### 3\. **Set (Интерфейс)**

**`Set`** — это подинтерфейс `Collection`, который представляет коллекцию уникальных элементов. В отличие от `List`, `Set` не гарантирует сохранение порядка элементов (если только это не специфично для конкретной реализации). Он исключает дублирование элементов.

Методы `Set`:

*   `add(E e)`: добавляет элемент, если его нет в коллекции.
*   `contains(Object o)`: проверяет наличие элемента.

#### Реализации:

*   **HashSet** — основан на хешировании, не гарантирует порядок.
*   **LinkedHashSet** — сохраняет порядок вставки.
*   **TreeSet** — хранит элементы в отсортированном порядке, основан на дереве.

### 4\. **Queue (Интерфейс)**

**`Queue`** — это подинтерфейс `Collection`, который представляет коллекцию для хранения элементов с возможностью извлечения в определённом порядке, например, в порядке их добавления (FIFO — First In, First Out).

Методы `Queue`:

*   `offer(E e)`: добавляет элемент в очередь.
*   `poll()`: извлекает и удаляет элемент из очереди.
*   `peek()`: извлекает, но не удаляет элемент.

#### Реализации:

*   **PriorityQueue** — очередь с приоритетом, элементы сортируются по их естественному порядку или через компаратор.
*   **LinkedList** — также может быть использован как очередь.

### 5\. **Deque (Интерфейс)**

**`Deque`** — это расширение интерфейса `Queue`, которое добавляет методы для работы с коллекциями в стиле двусторонней очереди (FIFO и LIFO — Last In, First Out). Элементы могут добавляться и извлекаться с обоих концов очереди.

Методы `Deque`:

*   `addFirst(E e)`: добавляет элемент в начало.
*   `addLast(E e)`: добавляет элемент в конец.
*   `removeFirst()`: удаляет и возвращает элемент с начала.
*   `removeLast()`: удаляет и возвращает элемент с конца.

#### Реализации:

*   **ArrayDeque** — эффективная реализация двусторонней очереди.
*   **LinkedList** — также может быть использован как `Deque`.

### 6\. **Map (Интерфейс)**

**`Map`** — это интерфейс, который представляет коллекцию, хранящую данные в виде пар "ключ-значение". В отличие от других коллекций, `Map` не наследует от `Collection` и используется для представления ассоциативных массивов. Он не позволяет хранить дубликаты ключей, но может содержать дублирующиеся значения.

Методы `Map`:

*   `put(K key, V value)`: добавляет пару ключ-значение.
*   `get(Object key)`: возвращает значение по ключу.
*   `remove(Object key)`: удаляет пару ключ-значение.

#### Реализации:

*   **HashMap** — основан на хешировании, не гарантирует порядок.
*   **LinkedHashMap** — сохраняет порядок вставки.
*   **TreeMap** — хранит элементы в отсортированном порядке по ключу.

* * *

### Иерархия коллекций: обзор

```plaintext
Collection
├── List (сохраняет порядок)
│   ├── ArrayList
│   ├── LinkedList
│   └── Vector
├── Set (не допускает дубликатов)
│   ├── HashSet
│   ├── LinkedHashSet
│   └── TreeSet
├── Queue (очередь)
│   ├── LinkedList
│   └── PriorityQueue
└── Map (отображение "ключ-значение")
    ├── HashMap
    ├── LinkedHashMap
    └── TreeMap
```

### Заключение

Иерархия коллекций в Java организована так, что различные интерфейсы и классы предоставляют гибкие и мощные инструменты для работы с данными. В зависимости от типа данных и требуемого поведения (порядок, уникальность элементов, производительность) можно выбрать подходящий тип коллекции для решения конкретных задач.

## 10. Расскажи отличие List от Set? [вопросы](#вопросы)


**`List`** и **`Set`** — это оба интерфейса в коллекциях Java, но они предназначены для разных целей и имеют разные особенности. Вот основные различия между ними:

### 1\. **Уникальность элементов**

*   **`List`**:  
    Коллекция `List` **допускает дубликаты** элементов. Это значит, что в одном списке могут быть одинаковые элементы, которые могут появляться несколько раз.
    
    Пример:
    
    ```java
    List<String> list = new ArrayList<>();
    list.add("apple");
    list.add("banana");
    list.add("apple");  // Допускается дублирование
    System.out.println(list);  // [apple, banana, apple]
    ```
    
*   **`Set`**:  
    Коллекция `Set` **не допускает дубликатов**. Это означает, что в одном множестве не может быть одинаковых элементов. При попытке добавить элемент, который уже есть в множестве, новый элемент не будет добавлен.
    
    Пример:
    
    ```java
    Set<String> set = new HashSet<>();
    set.add("apple");
    set.add("banana");
    set.add("apple");  // Дубликаты не добавляются
    System.out.println(set);  // [apple, banana]
    ```
    

### 2\. **Порядок элементов**

*   **`List`**:  
    Коллекция `List` **сохраняет порядок** элементов. Элементы в списке сохраняются в том порядке, в котором они были добавлены, и вы можете получить доступ к элементам по индексу (начиная с 0).
    
    Пример:
    
    ```java
    List<String> list = new ArrayList<>();
    list.add("apple");
    list.add("banana");
    System.out.println(list.get(0));  // apple
    ```
    
*   **`Set`**:  
    Коллекция `Set` **не гарантирует порядок** элементов (если только не используется специализированная реализация, такая как `LinkedHashSet`, которая сохраняет порядок вставки). Например, стандартная реализация `HashSet` не гарантирует, что элементы будут сохранены в порядке их добавления.
    
    Пример с `HashSet`:
    
    ```java
    Set<String> set = new HashSet<>();
    set.add("apple");
    set.add("banana");
    System.out.println(set);  // Порядок может быть произвольным, например, [banana, apple]
    ```
    
    Пример с `LinkedHashSet` (сохраняет порядок вставки):
    
    ```java
    Set<String> set = new LinkedHashSet<>();
    set.add("apple");
    set.add("banana");
    System.out.println(set);  // [apple, banana]
    ```
    

### 3\. **Доступ по индексу**

*   **`List`**:  
    Коллекция `List` позволяет получать доступ к элементам по **индексу**. Вы можете легко получить или изменить элемент по его позиции в списке.
    
    Пример:
    
    ```java
    List<String> list = new ArrayList<>();
    list.add("apple");
    list.add("banana");
    System.out.println(list.get(1));  // banana
    ```
    
*   **`Set`**:  
    Коллекция `Set` **не поддерживает доступ по индексу**, так как она не хранит элементы в порядке, зависящем от их добавления. Элементы в множестве не упорядочены, и, следовательно, невозможно обратиться к элементу по индексу.
    
    Пример:
    
    ```java
    Set<String> set = new HashSet<>();
    set.add("apple");
    set.add("banana");
    // set.get(0);  // Ошибка компиляции, так как Set не поддерживает индексацию
    ```
    

### 4\. **Производительность**

*   **`List`**: Для некоторых операций производительность в `List` может зависеть от реализации. Например, `ArrayList` имеет быструю работу с доступом по индексу, но вставка и удаление элементов в середине списка может быть менее эффективной. В то время как `LinkedList` обеспечивает быструю вставку и удаление элементов в начале и середине списка, но медленный доступ по индексу.
    
*   **`Set`**: В `Set` коллекции (например, в `HashSet`) поиск, добавление и удаление элементов обычно выполняются очень быстро, с временем выполнения около O(1) в среднем. Однако, так как порядок не гарантируется, операции с `Set` могут быть немного медленнее, чем с `List` в некоторых случаях, особенно если используется `TreeSet` (который сортирует элементы), где операции могут быть медленнее из-за необходимости поддержания порядка (O(log n)).
    

### 5\. **Типичные применения**

*   **`List`**: Используется, когда важен порядок элементов или когда необходимо иметь возможность получить элементы по индексу. Например, `List` идеально подходит для хранения данных в последовательности, когда порядок добавления имеет значение, или когда нужно сделать выборку по индексу.
    
*   **`Set`**: Используется, когда важно, чтобы коллекция содержала только уникальные элементы, и порядок элементов не имеет значения (или может быть важен в случае `LinkedHashSet`). Например, `Set` полезен, когда нужно хранить только уникальные значения, такие как уникальные ID или уникальные имена.
    

* * *

### Заключение

| Характеристика | **`List`** | **`Set`** |
| --- | --- | --- |
| **Дубликаты** | Допускает дубликаты | Не допускает дубликаты |
| **Порядок элементов** | Сохраняет порядок вставки | Не гарантирует порядок (если не `LinkedHashSet`) |
| **Доступ по индексу** | Поддерживает доступ по индексу | Не поддерживает доступ по индексу |
| **Типичные применения** | Когда важен порядок и доступ по индексу | Когда важна уникальность элементов |

В зависимости от задачи, вам нужно выбрать подходящий интерфейс: используйте `List`, если вам нужен порядок и доступ по индексу, и выбирайте `Set`, если вам нужно гарантировать уникальность элементов.

## 11. Расскажи отличие ArrayList от LinkedList? [вопросы](#вопросы)


**`ArrayList`** и **`LinkedList`** — это две реализации интерфейса **`List`** в Java, каждая из которых имеет свои особенности и области применения. Основное отличие между ними заключается в том, как они хранят элементы в памяти и как эффективно выполняют различные операции. Давайте рассмотрим их более детально:

### 1\. **Типы хранения данных**

*   **`ArrayList`**:
    
    *   `ArrayList` использует **массив** для хранения элементов. Это означает, что элементы хранятся в последовательных ячейках памяти, и при добавлении элементов (когда массив заканчивается) происходит его расширение.
    *   Из-за этого **`ArrayList`** имеет быстрый доступ к элементам по индексу (операция `get(int index)` выполняется за O(1)).
*   **`LinkedList`**:
    
    *   `LinkedList` использует **связанный список**, где каждый элемент (узел) содержит ссылку на следующий элемент (и, в случае двусвязного списка, на предыдущий).
    *   Каждый узел хранит объект и ссылку на следующий элемент, что делает работу с этим списком менее эффективной с точки зрения использования памяти по сравнению с массивом.

### 2\. **Производительность операций**

| Операция | **`ArrayList`** | **`LinkedList`** |
| --- | --- | --- |
| **Доступ по индексу** | O(1) | O(n) |
| **Добавление в конец** | O(1) (если нет необходимости в увеличении размера массива) | O(1) (связанный список позволяет добавлять в конец быстро) |
| **Добавление в начало** | O(n) (необходимо сдвигать элементы) | O(1) (добавление элемента в начало списка требует лишь изменения ссылки) |
| **Удаление из конца** | O(1) (если размер массива не нужно изменять) | O(1) |
| **Удаление из начала** | O(n) (сдвиг элементов) | O(1) (удаление из начала списка требует лишь изменения ссылки) |
| **Добавление в середину** | O(n) (сдвиг элементов) | O(n) (поиск элемента в середине требует O(n), и добавление также требует O(1) после нахождения) |

*   **`ArrayList`** обладает хорошей производительностью при доступе по индексу, а также при добавлении элементов в конец, когда размер массива не превышает его текущую емкость.
*   **`LinkedList`** превосходит **`ArrayList`** при добавлении или удалении элементов в начале или в середине списка, так как не требуется сдвигать элементы (в отличие от массива).

### 3\. **Использование памяти**

*   **`ArrayList`**:  
    Использует массив для хранения элементов. При расширении массива Java создает новый массив большего размера, копирует туда все элементы и заменяет старый массив. Это может занимать дополнительную память в случае необходимости расширения.
    
    Также элементы **`ArrayList`** хранятся в смежных блоках памяти, что делает его более эффективным для кэширования (когда элементы часто используются), так как процессор может эффективно загружать элементы, размещённые подряд.
    
*   **`LinkedList`**:  
    Каждый элемент в `LinkedList` хранит ссылки на предыдущий и следующий элемент. Это приводит к большему использованию памяти, так как каждому элементу требуется дополнительное пространство для ссылок (2 ссылки на каждый элемент — на следующий и предыдущий). Также, элементы не хранятся в смежных блоках памяти, что снижает эффективность кэширования.
    

### 4\. **Операции с памятью**

*   **`ArrayList`**:  
    Когда элементы превышают текущий размер массива, происходит **перераспределение** памяти, что может быть относительно дорогой операцией, так как старые элементы нужно скопировать в новый массив. Однако после этого доступ к элементам становится очень быстрым.
    
*   **`LinkedList`**:  
    **Добавление и удаление элементов** не требует перераспределения памяти. Однако поиск элемента по индексу может быть медленным, так как для этого требуется пройти по списку от начала или конца до нужного элемента.
    

### 5\. **Типичные применения**

*   **`ArrayList`** лучше использовать в следующих случаях:
    
    *   Когда **нужно частое обращение к элементам по индексу**.
    *   Когда коллекция не изменяется слишком часто (например, не часто происходят вставки и удаления).
    *   Когда важна производительность при **поиске** или **переборе** элементов.
*   **`LinkedList`** лучше использовать в следующих случаях:
    
    *   Когда в основном требуется выполнять **добавление или удаление элементов в начале или в середине коллекции**.
    *   Когда важна производительность при **добавлении/удалении элементов** в любых местах списка.
    *   Когда вам не важна производительность по индексу и вы не планируете часто делать случайные доступы к элементам.

### 6\. **Пример использования**

```java
// Использование ArrayList
List<String> arrayList = new ArrayList<>();
arrayList.add("apple");
arrayList.add("banana");
arrayList.add("orange");
System.out.println(arrayList.get(1));  // Быстрый доступ по индексу

// Использование LinkedList
List<String> linkedList = new LinkedList<>();
linkedList.add("apple");
linkedList.add("banana");
linkedList.add("orange");
System.out.println(linkedList.get(1));  // Доступ по индексу медленнее
```

### Заключение

| Характеристика | **`ArrayList`** | **`LinkedList`** |
| --- | --- | --- |
| **Хранение данных** | Использует массив | Использует связанный список (ссылки) |
| **Доступ по индексу** | O(1) | O(n) |
| **Добавление в конец** | O(1) (при условии, что нет расширения) | O(1) |
| **Добавление в начало/середину** | O(n) (необходимо сдвигать элементы) | O(1) (для начала, O(n) для середины) |
| **Удаление в начале/середине** | O(n) (сдвиг элементов) | O(1) (для начала, O(n) для середины) |
| **Использование памяти** | Элементы в смежных ячейках памяти | Каждый элемент требует дополнительной памяти для ссылок |
| **Типичные применения** | Частый доступ по индексу, мало изменений | Частое добавление/удаление в начале/середине |

Выбор между `ArrayList` и `LinkedList` зависит от типа операций, которые вы будете выполнять, и от того, какой аспект производительности для вас более важен.

## 12. Когда лучше использовать ArrayList, а когда LinkedList? [вопросы](#вопросы)


Выбор между **`ArrayList`** и **`LinkedList`** зависит от того, какие операции вы будете выполнять чаще всего и какие аспекты производительности для вас более важны. Рассмотрим, когда лучше использовать каждую из этих коллекций.

### Когда использовать **`ArrayList`**:

1.  **Частый доступ по индексу**:
    
    *   **`ArrayList`** предоставляет быстрый доступ по индексу — операция `get(int index)` выполняется за O(1). Если ваша программа часто запрашивает элементы по индексу, `ArrayList` будет более эффективным выбором.
    
    Пример:
    
    ```java
    List<String> list = new ArrayList<>();
    list.add("apple");
    list.add("banana");
    System.out.println(list.get(1));  // Быстрый доступ к элементу
    ```
    
2.  **Редкие добавления или удаления в середине списка**:
    
    *   Если вы часто добавляете или удаляете элементы в середине списка или в начале, то **`ArrayList`** будет менее эффективен, так как при этих операциях нужно сдвигать элементы. Но если операции добавления/удаления происходят только в конце списка, то **`ArrayList`** очень эффективен (O(1)).
3.  **Когда важна компактность в памяти**:
    
    *   **`ArrayList`** использует массив, который более компактен по сравнению с `LinkedList`, так как не нужно хранить дополнительные ссылки на следующий и предыдущий элементы. Если вам важна экономия памяти и вы работаете с большим количеством данных, **`ArrayList`** может быть предпочтительнее.
4.  **Когда ожидается, что размер списка будет редко изменяться**:
    
    *   **`ArrayList`** хорошо подходит, если размер коллекции не будет часто изменяться, так как расширение массива может быть дорогой операцией. Если элементы добавляются в конец с редкими расширениями массива, производительность будет хорошей.

### Когда использовать **`LinkedList`**:

1.  **Частое добавление и удаление элементов в начале или середине**:
    
    *   Если ваша программа часто добавляет или удаляет элементы в начале или середине коллекции, **`LinkedList`** будет намного эффективнее, так как для этого не нужно сдвигать элементы (операции добавления и удаления выполняются за O(1), если известна позиция).
    
    Пример:
    
    ```java
    List<String> list = new LinkedList<>();
    list.addFirst("apple");  // Добавление в начало
    list.addLast("banana");   // Добавление в конец
    list.removeFirst();       // Удаление из начала
    list.removeLast();        // Удаление из конца
    ```
    
2.  **Когда важна производительность при операциях вставки или удаления**:
    
    *   Если ваш алгоритм требует часто выполнять вставки или удаления в середине списка (например, в очереди или двусторонней очереди), **`LinkedList`** — это подходящий выбор, так как операции вставки и удаления выполняются за O(1) в случае двусвязного списка.
3.  **Когда не нужен быстрый доступ по индексу**:
    
    *   **`LinkedList`** не подходит для частого доступа по индексу, так как время поиска элемента по индексу — O(n). Если вы не планируете часто получать элементы по индексу, то **`LinkedList`** может быть подходящим выбором, особенно если важны операции вставки и удаления.
4.  **Когда список часто меняет размер**:
    
    *   **`LinkedList`** может быть предпочтительнее, если список часто меняет свой размер, так как он динамически выделяет память для каждого элемента и не требует перераспределения, как это происходит в `ArrayList`.

### Примеры, когда выбрать **`ArrayList`** или **`LinkedList`**:

#### **`ArrayList`**:

*   Приложение, где вам нужно часто **по индексу** получать элементы.
*   Список, в который элементы **добавляются в конец** и редко вставляются или удаляются в середине или в начале.
*   Когда требуется **экономия памяти** и более компактное представление данных.
*   Когда количество элементов не меняется слишком часто, и не требуется частое расширение списка.

#### **`LinkedList`**:

*   Приложение, где вам нужно часто **вставлять или удалять элементы в начале или середине** списка.
*   Структуры данных, такие как **очереди**, **стэки** или **дек** (двусторонняя очередь), где важно быстрое добавление и удаление элементов.
*   Когда вам не важна производительность при **доступе по индексу** и вам нужно часто изменять размер коллекции.

### Заключение

| Характеристика | **`ArrayList`** | **`LinkedList`** |
| --- | --- | --- |
| **Частый доступ по индексу** | Быстрый доступ (O(1)) | Медленный доступ (O(n)) |
| **Добавление в конец** | O(1), если не требуется перераспределение | O(1) |
| **Добавление в начало/середину** | O(n) (необходимо сдвигать элементы) | O(1) (для начала и конца, O(n) для середины) |
| **Удаление из начала/середины** | O(n) (необходимо сдвигать элементы) | O(1) (для начала и конца, O(n) для середины) |
| **Использование памяти** | Более компактное, требует меньше памяти | Требует больше памяти из-за хранения ссылок |
| **Использование** | Часто используется для случайного доступа по индексу | Часто используется для очередей, стэков и при частом добавлении/удалении элементов в середине |

Выбор между **`ArrayList`** и **`LinkedList`** зависит от конкретных требований вашего приложения.

## 13. В чём разница между Queue и Deque и Stack? [вопросы](#вопросы)


В Java **`Queue`**, **`Deque`** и **`Stack`** — это разные интерфейсы и структуры данных, которые имеют различные особенности и применяются в разных случаях в зависимости от того, как нужно обрабатывать элементы в коллекции.

### 1\. **Queue (Очередь)**

**`Queue`** — это структура данных, которая работает по принципу **FIFO (First In, First Out)**, т.е. элементы добавляются в конец очереди и извлекаются с начала очереди.

*   **Основные операции**:
    
    *   **`add(E e)`** — добавляет элемент в очередь.
    *   **`remove()`** — удаляет и возвращает элемент с начала очереди (бросает исключение, если очередь пуста).
    *   **`peek()`** — возвращает, но не удаляет элемент с начала очереди (если очередь пуста, возвращает `null`).
*   **Пример использования**: Очередь часто используется для задач, связанных с обработкой данных в том порядке, в котором они поступили, например, в обработке запросов от клиентов или в планировании задач.
    
    ```java
    Queue<String> queue = new LinkedList<>();
    queue.add("A");
    queue.add("B");
    queue.add("C");
    
    System.out.println(queue.remove());  // A
    System.out.println(queue.peek());    // B
    ```
    

### 2\. **Deque (Двусторонняя очередь)**

**`Deque`** (от англ. **Double Ended Queue**) — это структура данных, которая поддерживает добавление и удаление элементов как с **переднего**, так и с **заднего** конца. Она является расширением очереди и работает как обычная очередь, но также поддерживает функции **Stack** (стека) и **Queue** (очереди).

*   **Основные операции**:
    
    *   **`addFirst(E e)`** — добавляет элемент в начало очереди.
    *   **`addLast(E e)`** — добавляет элемент в конец очереди.
    *   **`removeFirst()`** — удаляет и возвращает элемент с начала очереди.
    *   **`removeLast()`** — удаляет и возвращает элемент с конца очереди.
    *   **`peekFirst()`** — возвращает, но не удаляет элемент с начала.
    *   **`peekLast()`** — возвращает, но не удаляет элемент с конца.
*   **Пример использования**: **`Deque`** полезен, когда нужно иметь возможность работать как с очередью, так и с стеком, например, при реализации двусторонней очереди, очереди с приоритетом или при реализации алгоритмов, требующих работы с обоими концами структуры данных.
    
    ```java
    Deque<String> deque = new LinkedList<>();
    deque.addFirst("A");
    deque.addLast("B");
    deque.addFirst("C");
    
    System.out.println(deque.removeFirst());  // C
    System.out.println(deque.removeLast());   // B
    ```
    

### 3\. **Stack (Стек)**

**`Stack`** — это структура данных, которая работает по принципу **LIFO (Last In, First Out)**, т.е. последний добавленный элемент будет первым извлечённым.

*   **Основные операции**:
    
    *   **`push(E e)`** — добавляет элемент на верх стека.
    *   **`pop()`** — удаляет и возвращает верхний элемент стека.
    *   **`peek()`** — возвращает, но не удаляет верхний элемент стека.
    *   **`empty()`** — проверяет, пуст ли стек.
*   **Пример использования**: Стек используется, когда необходимо обрабатывать элементы в обратном порядке, например, при решении задач на обработку выражений или реализации рекурсии.
    
    ```java
    Stack<String> stack = new Stack<>();
    stack.push("A");
    stack.push("B");
    stack.push("C");
    
    System.out.println(stack.pop());  // C
    System.out.println(stack.peek()); // B
    ```
    

### Ключевые различия:

| Особенность | **Queue** | **Deque** | **Stack** |
| --- | --- | --- | --- |
| **Принцип работы** | FIFO (First In, First Out) | Двусторонняя очередь (FIFO или LIFO) | LIFO (Last In, First Out) |
| **Операции с концами** | Только с начала (передний конец) | Добавление/удаление с обоих концов | Только с верхнего конца (стек) |
| **Типичные применения** | Очереди запросов, задачи с очередностью | Двусторонние очереди, очереди с приоритетом, алгоритмы с работой с обоими концами | Алгоритмы, где требуется обработка в обратном порядке, например, обход дерева |
| **Поддерживаемые операции** | add(), remove(), peek() | addFirst(), addLast(), removeFirst(), removeLast(), peekFirst(), peekLast() | push(), pop(), peek() |

### Резюме:

*   **`Queue`** — очередь с добавлением в конец и извлечением из начала (FIFO).
*   **`Deque`** — двусторонняя очередь, которая позволяет добавлять и извлекать элементы с обоих концов (поддерживает как поведение очереди, так и стека).
*   **`Stack`** — структура данных с принципом работы LIFO, используется для обработки элементов в обратном порядке.

Каждая из этих структур имеет свою нишу и используется в зависимости от того, какой порядок обработки элементов требуется в вашем приложении.

## 14. Отличие двусвязного и односвязного списка? [вопросы](#вопросы)


**Односвязный** и **двусвязный список** — это два типа **связанных списков**, которые отличаются количеством ссылок, которые каждый элемент (узел) списка хранит на другие элементы. Давайте рассмотрим их особенности и различия.

### 1\. **Односвязный список (Singly Linked List)**

В **односвязном списке** каждый узел хранит два компонента:

*   **Данные** (или значение) — сам элемент данных.
*   **Ссылка** (или указатель) на **следующий** узел в списке.

Последний узел списка содержит ссылку на **`null`**, что означает конец списка.

#### Структура узла:

```java
class Node {
    int data;
    Node next;  // ссылка на следующий элемент
}
```

#### Особенности:

*   Каждый узел в **односвязном списке** связан только с **следующим узлом**.
*   **Операции**:
    *   **Добавление** элемента — добавление нового элемента требует изменения только одной ссылки.
    *   **Удаление** элемента — удаление узла также требует изменения лишь одной ссылки (на следующий элемент).
    *   **Доступ** к элементу — для доступа к элементу необходимо пройти от головы списка до нужного узла.

#### Преимущества:

*   Меньше памяти для хранения ссылки (только одна ссылка).
*   Простой и эффективный в использовании для операций добавления/удаления в начале списка.

#### Недостатки:

*   Операции доступа по индексу более медленные (O(n)), так как требуется проходить по всем узлам от головы до нужного.
*   Нет возможности быстро перемещаться в обратную сторону, поскольку нет ссылки на предыдущий узел.

* * *

### 2\. **Двусвязный список (Doubly Linked List)**

В **двусвязном списке** каждый узел хранит три компонента:

*   **Данные** — сам элемент данных.
*   **Ссылка на следующий узел** (next).
*   **Ссылка на предыдущий узел** (prev).

Таким образом, каждый узел может быть как связан с предыдущим, так и с следующим узлом, что позволяет перемещаться как вперед, так и назад.

#### Структура узла:

```java
class Node {
    int data;
    Node next;  // ссылка на следующий элемент
    Node prev;  // ссылка на предыдущий элемент
}
```

#### Особенности:

*   Каждый узел в **двусвязном списке** хранит две ссылки: на **предыдущий** и на **следующий** узлы.
*   **Операции**:
    *   **Добавление** и **удаление** элементов можно выполнить как с начала, так и с конца списка, что делает эти операции более гибкими и эффективными.
    *   **Доступ** к элементам может быть выполнен как с начала, так и с конца списка, в зависимости от того, где ближе к нужному элементу.

#### Преимущества:

*   Возможность **перемещения** в обе стороны (вперед и назад).
*   Операции добавления/удаления в обеих концах списка могут быть выполнены быстрее, чем в односвязном списке (например, удаление последнего элемента).
*   Быстрый доступ к предыдущему элементу, что полезно при реализации алгоритмов, требующих этого.

#### Недостатки:

*   Требует больше памяти для хранения дополнительных ссылок.
*   Более сложная реализация из-за управления двумя ссылками для каждого узла.

* * *

### Сравнение:

| Характеристика | **Односвязный список** | **Двусвязный список** |
| --- | --- | --- |
| **Количество ссылок в узле** | 1 (ссылка на следующий узел) | 2 (ссылки на следующий и предыдущий узлы) |
| **Память** | Менее затратен по памяти | Требует больше памяти (для каждой ссылки) |
| **Перемещение** | Только вперед (от головы до конца) | Вперед и назад (от головы и хвоста) |
| **Операции добавления/удаления** | Быстрее при добавлении/удалении в начале | Быстрее при добавлении/удалении с обоих концов |
| **Операции доступа** | Операции поиска требуют прохода от головы к нужному элементу | Доступ можно осуществить с обеих сторон списка |
| **Операции с конца списка** | Труднее (нужно идти от головы) | Легче, доступен хвост (через prev) |

### Заключение:

*   **Односвязный список** подходит, если вы часто добавляете/удаляете элементы в начале списка и вам не нужно быстро перемещаться по списку в обе стороны.
*   **Двусвязный список** подходит, если вам нужно чаще выполнять операции с концами списка или если вам нужно перемещаться в обе стороны списка, например, в реализации алгоритмов с произвольным доступом к элементам.

## 15. Как работает HashSet? [вопросы](#вопросы)


**`HashSet`** — это коллекция в Java, которая реализует интерфейс **`Set`**. Она представляет собой **множество**, в котором не допускаются дублирующиеся элементы и порядок элементов не сохраняется. **`HashSet`** использует **хеширование** для организации элементов и быстрых операций добавления, удаления и проверки присутствия элемента.

### Как работает `HashSet`?

1.  **Хеширование**:
    
    *   Когда элемент добавляется в **`HashSet`**, он хешируется с использованием его хеш-кода (метод `hashCode()`).
    *   Хеш-код элемента вычисляется с помощью метода `hashCode()`, который является частью класса `Object` и может быть переопределен в пользовательских классах.
    *   Этот хеш-код используется для вычисления индекса в массиве, который будет хранить этот элемент. Элементы с одинаковым хеш-кодом будут попадать в одну и ту же "корзину" (bucket), но хеш-коллизии обрабатываются специальным образом.
2.  **Реализация на основе массива**:
    
    *   **`HashSet`** использует внутренний массив для хранения элементов. Каждый элемент помещается в корзину, которая определяется хеш-кодом.
    *   Для каждого хеш-кода (или индекса) есть **корзина**, в которой хранятся все элементы, имеющие одинаковый хеш-код (это так называемая **коллизия**).
    *   В случае коллизий используется структура данных, такая как **связанный список** или **дерево**, для хранения нескольких элементов с одинаковым хеш-кодом в одной корзине.
3.  **Метод `hashCode()` и `equals()`**:
    
    *   Для того чтобы два объекта считались одинаковыми, не достаточно просто совпадения хеш-кодов. **`HashSet`** использует метод `equals()` для проверки, равны ли два элемента.
    *   Если два элемента имеют одинаковый хеш-код, но их значения различаются, то они будут считаться разными элементами, так как метод `equals()` вернет `false`.
    *   Если хеш-коды равны, то **`equals()`** используется для окончательной проверки на равенство.
4.  **Операции в `HashSet`**:
    
    *   **`add(E e)`** — добавляет элемент в множество, если он еще не присутствует. Если элемент уже есть в наборе, операция не изменяет набор (и возвращает `false`).
    *   **`contains(Object o)`** — проверяет, присутствует ли элемент в множестве.
    *   **`remove(Object o)`** — удаляет элемент из множества, если он есть.
    *   **`size()`** — возвращает количество элементов в наборе.
    *   **`clear()`** — удаляет все элементы из множества.

### Пример работы `HashSet`:

```java
import java.util.HashSet;

public class HashSetExample {
    public static void main(String[] args) {
        // Создаем HashSet
        HashSet<String> set = new HashSet<>();
        
        // Добавляем элементы
        set.add("Apple");
        set.add("Banana");
        set.add("Orange");
        
        // Пытаемся добавить дубликат
        set.add("Apple"); // Не будет добавлен, так как Apple уже есть
        
        // Проверяем размер множества
        System.out.println("Size: " + set.size());  // 3
        
        // Проверяем наличие элемента
        System.out.println("Contains 'Banana': " + set.contains("Banana"));  // true
        System.out.println("Contains 'Grapes': " + set.contains("Grapes"));  // false
        
        // Удаляем элемент
        set.remove("Orange");
        System.out.println("Size after remove: " + set.size());  // 2
        
        // Перебор элементов
        for (String fruit : set) {
            System.out.println(fruit);
        }
    }
}
```

### Важные особенности `HashSet`:

1.  **Отсутствие порядка**:
    
    *   **`HashSet`** не гарантирует порядок элементов. Это означает, что элементы могут быть перебраны в произвольном порядке, в отличие от **`LinkedHashSet`**, который сохраняет порядок добавления элементов.
2.  **Отсутствие дубликатов**:
    
    *   **`HashSet`** не допускает дубликатов. Если вы попытаетесь добавить элемент, который уже существует в множестве, операция добавления не будет выполнена, и коллекция останется неизменной.
3.  **Быстрая производительность**:
    
    *   Благодаря хешированию операции добавления, удаления и проверки на наличие элемента в **`HashSet`** выполняются за **время O(1)** в среднем (хотя могут быть и случаи с коллизиями, которые немного ухудшают производительность).
4.  **Реализация интерфейса `Set`**:
    
    *   **`HashSet`** является реализацией интерфейса `Set`, что означает, что он не позволяет хранить одинаковые элементы, в отличие от коллекций, таких как `List` или `Queue`.

### Преимущества `HashSet`:

*   **Быстрота**: Быстрое добавление, удаление и поиск элементов (в среднем O(1)).
*   **Отсутствие дубликатов**: Автоматически не позволяет хранить одинаковые элементы.
*   **Хеширование**: Эффективно распределяет элементы по корзинам, минимизируя коллизии.

### Недостатки:

*   **Отсутствие порядка**: Если вам нужно сохранить порядок добавления элементов, используйте **`LinkedHashSet`**.
*   **Память**: Требует больше памяти по сравнению с простыми списками или массивами из-за хранения хеш-кодов и дополнительных данных для обработки коллизий.

### Заключение:

**`HashSet`** — это мощная коллекция для хранения уникальных элементов с быстрыми операциями добавления, удаления и поиска. Однако следует помнить, что она не сохраняет порядок элементов, и в случае с коллизиями производительность может немного ухудшаться.

## 16. Как работает метод contains в ArrayList, LinkedList, HashSet? [вопросы](#вопросы)


Метод **`contains()`** в коллекциях Java используется для проверки, присутствует ли элемент в коллекции. Однако, поскольку разные коллекции реализуют свои внутренние структуры данных по-разному, время выполнения этого метода и его реализация будут отличаться. Рассмотрим, как работает **`contains()`** в различных коллекциях:

* * *

### 1\. **`ArrayList`**:

**`ArrayList`** — это динамический массив, который хранит элементы в виде непрерывного блока памяти. Когда вызывается метод **`contains()`**, происходит поиск элемента в списке.

#### Как работает:

*   **Алгоритм**: **Линейный поиск**.
*   **Время выполнения**: **O(n)**, где n — количество элементов в списке.
*   При вызове **`contains()`** метод проходит по всем элементам списка и проверяет, совпадает ли искомый элемент с текущим (с помощью метода `equals()`).
*   Если элемент найден, метод возвращает `true`, иначе — `false`.

#### Пример:

```java
ArrayList<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Orange");

System.out.println(list.contains("Banana"));  // true
System.out.println(list.contains("Grapes"));  // false
```

### 2\. **`LinkedList`**:

**`LinkedList`** — это связанный список, который хранит элементы в виде узлов, где каждый узел содержит данные и ссылки на предыдущий и следующий элементы.

#### Как работает:

*   **Алгоритм**: **Линейный поиск**.
*   **Время выполнения**: **O(n)**, где n — количество элементов в списке.
*   Когда вызывается **`contains()`**, метод начинает с головы списка и последовательно переходит к следующему элементу через ссылки (по одной ссылке за раз), проверяя каждый элемент на равенство с искомым (с использованием `equals()`).
*   Если элемент найден, метод возвращает `true`, иначе — `false`.

#### Пример:

```java
LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
linkedList.add("Orange");

System.out.println(linkedList.contains("Banana"));  // true
System.out.println(linkedList.contains("Grapes"));  // false
```

### 3\. **`HashSet`**:

**`HashSet`** — это коллекция, основанная на **хешировании**. Она использует хеш-таблицу для хранения элементов, что делает поиск по ключу очень быстрым.

#### Как работает:

*   **Алгоритм**: **Хеширование**.
*   **Время выполнения**: **O(1)** в среднем (в худшем случае — O(n), если много коллизий).
*   Когда вызывается **`contains()`**, метод вычисляет хеш-код элемента и использует его для поиска соответствующей корзины в хеш-таблице. Если корзина не пуста, метод далее сравнивает элементы в корзине с искомым (с помощью метода `equals()`).
*   Если элемент найден в соответствующей корзине, метод возвращает `true`, иначе — `false`.

#### Пример:

```java
HashSet<String> hashSet = new HashSet<>();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Orange");

System.out.println(hashSet.contains("Banana"));  // true
System.out.println(hashSet.contains("Grapes"));  // false
```

### Сравнение работы метода **`contains()`**:

| Коллекция | Структура данных | Алгоритм поиска | Время выполнения | Примечания |
| --- | --- | --- | --- | --- |
| **`ArrayList`** | Массив | Линейный поиск | O(n) | Проходит по всем элементам в списке. |
| **`LinkedList`** | Связанный список | Линейный поиск | O(n) | Проходит через узлы, начиная с головы. |
| **`HashSet`** | Хеш-таблица | Хеширование (по хеш-коду) | O(1) в среднем | Быстрый доступ за счет хеширования, но возможны коллизии. |

### Резюме:

*   **`ArrayList`** и **`LinkedList`** используют **линейный поиск**, поэтому время выполнения **`contains()`** пропорционально количеству элементов в коллекции (**O(n)**).
*   **`HashSet`** использует **хеширование**, что позволяет найти элемент за **O(1)** в среднем, обеспечивая значительно более быстрый поиск, чем в списках, если хеширование работает эффективно.

## 17. В чём разница между Iterable и Iterator? [вопросы](#вопросы)


**`Iterable`** и **`Iterator`** — это два интерфейса в Java, которые часто используются для работы с коллекциями и другими объектами, которые можно перебирать. Они связаны, но выполняют разные роли.

### 1\. **`Iterable`**:

**`Iterable`** — это интерфейс, который представляет собой объект, по которому можно **перебирать** элементы с помощью **`Iterator`**. Это основной интерфейс, который делает коллекцию или объект **перебираемым** в Java.

#### Основные особенности:

*   **Метод**:
    *   **`iterator()`** — единственный метод интерфейса **`Iterable`**. Этот метод должен возвращать новый **`Iterator`**, который будет использоваться для перебора элементов.
*   **Обязанность**:
    *   Если класс реализует **`Iterable`**, то объекты этого класса можно использовать в конструкциях типа **`for-each`**, которые автоматически используют **`iterator()`** для перебора элементов.

#### Пример реализации:

```java
import java.util.Iterator;

public class MyIterable implements Iterable<Integer> {
    private Integer[] data = {1, 2, 3, 4, 5};
    
    @Override
    public Iterator<Integer> iterator() {
        return new Iterator<Integer>() {
            private int index = 0;
            
            @Override
            public boolean hasNext() {
                return index < data.length;
            }
            
            @Override
            public Integer next() {
                return data[index++];
            }
        };
    }
}
```

#### Пример использования:

```java
MyIterable iterable = new MyIterable();
for (Integer num : iterable) {
    System.out.println(num);
}
```

### 2\. **`Iterator`**:

**`Iterator`** — это интерфейс, который предоставляет механизмы для **перебора** элементов коллекции. Он является фактическим инструментом для **перемещения по элементам** в коллекции.

#### Основные особенности:

*   **Методы**:
    *   **`hasNext()`** — проверяет, есть ли еще элементы для перебора (возвращает `true`, если следующий элемент существует).
    *   **`next()`** — возвращает следующий элемент в коллекции.
    *   **`remove()`** — удаляет последний возвращенный элемент (опциональный метод).
*   **Обязанности**:
    *   **`Iterator`** предоставляет логику для **перемещения** по коллекции и извлечения элементов.
    *   Он используется для явного **перебора элементов** с помощью вызова метода `next()`, а также для проверки, есть ли еще элементы с помощью метода `hasNext()`.

#### Пример реализации:

```java
import java.util.Iterator;
import java.util.ArrayList;

public class IteratorExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        
        Iterator<String> iterator = list.iterator();  // Получаем итератор
        
        while (iterator.hasNext()) {
            System.out.println(iterator.next());  // Перебираем элементы
        }
    }
}
```

### Основные различия:

| Характеристика | **`Iterable`** | **`Iterator`** |
| --- | --- | --- |
| **Роль** | Обеспечивает объект, который можно перебирать. | Предоставляет методы для перебора элементов коллекции. |
| **Методы** | 1 метод: `iterator()` | 3 метода: `hasNext()`, `next()`, `remove()` |
| **Применение** | Используется для объектов, которые могут быть перебраны в **`for-each`** цикле. | Используется для явного перебора элементов в коллекции. |
| **Основной объект** | Представляет коллекцию как объект, который можно перебирать. | Осуществляет конкретное перебирание элементов коллекции. |
| **Типичный пример использования** | Коллекции и другие объекты, которые реализуют `Iterable`. | Перебор элементов с помощью методов `hasNext()` и `next()`. |

### Заключение:

*   **`Iterable`** — это интерфейс, который делает объект **перебираемым** с помощью **`Iterator`**.
*   **`Iterator`** — это интерфейс, который предоставляет конкретные методы для **перебора** элементов коллекции по одному за раз.

Вместе они позволяют эффективно работать с коллекциями в Java и упрощают использование **`for-each`** цикла.

## 18. Что такое Iterator? [вопросы](#вопросы)


**`Iterator`** — это интерфейс в Java, который предоставляет методы для **перебора** элементов коллекции. Он является частью коллекций, которые поддерживают последовательный доступ к своим элементам. **`Iterator`** позволяет вам итерировать через коллекцию, извлекая элементы по одному и управляя текущим состоянием перебора.

### Основные методы интерфейса `Iterator`:

1.  **`hasNext()`**:
    
    *   Возвращает `true`, если в коллекции есть следующий элемент.
    *   Возвращает `false`, если текущий элемент — последний, и после него нет элементов.
    
    ```java
    boolean hasNext();
    ```
    
2.  **`next()`**:
    
    *   Возвращает следующий элемент в коллекции.
    *   Вызывает ошибку **`NoSuchElementException`**, если элементов больше нет (когда `hasNext()` возвращает `false`).
    
    ```java
    E next();
    ```
    
3.  **`remove()`**:
    
    *   Удаляет последний элемент, который был возвращен методом `next()`.
    *   Этот метод необязателен и может быть не реализован в некоторых коллекциях. Если он поддерживается, его вызов удаляет текущий элемент из коллекции.
    
    ```java
    void remove();
    ```
    

### Пример использования `Iterator`:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");
        
        // Получаем Iterator для коллекции
        Iterator<String> iterator = list.iterator();
        
        // Перебор с использованием Iterator
        while (iterator.hasNext()) {
            String fruit = iterator.next();
            System.out.println(fruit);
        }
    }
}
```

### Пример использования метода `remove()`:

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorRemoveExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Получаем Iterator
        Iterator<String> iterator = list.iterator();

        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if ("Banana".equals(fruit)) {
                // Удаляем "Banana" во время перебора
                iterator.remove();
            }
        }

        // Печатаем коллекцию после удаления
        System.out.println(list);  // [Apple, Orange]
    }
}
```

### Особенности:

*   **Итератор** предоставляет **безопасный способ перебора** коллекции, так как исключает проблемы с конкурентным изменением коллекции (например, если элементы коллекции удаляются во время перебора).
*   Вызывая **`remove()`** через **`Iterator`**, можно избежать **`ConcurrentModificationException`**, которая может возникнуть при модификации коллекции во время её перебора через стандартный **`for-each`** цикл.

### Типы коллекций, поддерживающие `Iterator`:

Все коллекции, такие как **`ArrayList`**, **`HashSet`**, **`LinkedList`** и другие, поддерживают **`Iterator`**. Это позволяет применять одинаковый механизм перебора к разным коллекциям.

## 19. В каких случаях нужно использовать iterator? И почему? [вопросы](#вопросы)


Использование **`Iterator`** в Java имеет несколько ключевых случаев, когда он становится полезным и необходимым инструментом для работы с коллекциями. Вот основные ситуации, когда стоит использовать **`Iterator`**:

### 1\. **Перебор коллекции, когда структура коллекции может изменяться во время итерации**

Когда вы хотите **удалить элементы** из коллекции во время ее перебора, использование **`Iterator`** помогает избежать **`ConcurrentModificationException`**, которая возникает, если вы изменяете коллекцию (например, удаляете элементы) при использовании обычного цикла **`for-each`** или стандартного **`for`**.

#### Пример:

Если вы пытаетесь удалить элементы из коллекции в процессе перебора с использованием **`for-each`** или обычного цикла, то при изменении коллекции возникает ошибка **`ConcurrentModificationException`**. Однако с помощью **`Iterator`** можно безопасно удалять элементы.

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorRemoveExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Orange");

        // Получаем Iterator
        Iterator<String> iterator = list.iterator();

        while (iterator.hasNext()) {
            String fruit = iterator.next();
            if ("Banana".equals(fruit)) {
                // Удаляем "Banana" во время перебора
                iterator.remove();
            }
        }

        // Печатаем коллекцию после удаления
        System.out.println(list);  // [Apple, Orange]
    }
}
```

### 2\. **Когда нужно избежать использования индексов**

Если вам нужно работать с коллекцией, которая не поддерживает индексы (например, **`Set`** или **`LinkedList`**), вы не можете использовать обычный цикл с индексами, как в **`for`** или **`for-each`**. В таких случаях **`Iterator`** является единственным способом перебора элементов.

#### Пример:

Для **`Set`** (например, **`HashSet`** или **`LinkedHashSet`**), которые не поддерживают индексацию, можно использовать только **`Iterator`** для перебора элементов.

```java
import java.util.HashSet;
import java.util.Iterator;

public class SetIteratorExample {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Orange");

        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}
```

### 3\. **Когда необходимо произвести особую обработку элементов коллекции**

Иногда, при переборе коллекции, вам может понадобиться произвести более сложную обработку элементов, например, комбинировать элементы с дополнительной логикой или проверкой состояния коллекции. **`Iterator`** предоставляет полный контроль над итерацией через методы **`hasNext()`**, **`next()`** и **`remove()`**.

#### Пример:

Предположим, что вы хотите пройтись по коллекции и выполнить специфическую логику для определенных элементов, а также удалить их, если они соответствуют некоторым критериям.

```java
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorComplexExample {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.add(5);

        Iterator<Integer> iterator = list.iterator();

        while (iterator.hasNext()) {
            int number = iterator.next();
            if (number % 2 == 0) {
                // Удаляем все четные числа
                iterator.remove();
            }
        }

        // Печатаем коллекцию после удаления четных чисел
        System.out.println(list);  // [1, 3, 5]
    }
}
```

### 4\. **Когда вам нужно явно контролировать процесс итерации**

**`Iterator`** предоставляет полное управление процессом перебора коллекции. Если вам нужно изменять состояние во время перебора (например, вести подсчет или делать дополнительные проверки), использование **`Iterator`** даст вам гибкость для этого.

### 5\. **Когда нужно работать с коллекциями, не поддерживающими индексацию**

Коллекции, такие как **`Set`** (например, **`HashSet`**, **`TreeSet`**) или **`Queue`**, не поддерживают прямой доступ к элементам через индексы, в отличие от **`List`**. В таких случаях **`Iterator`** является единственным способом перебора элементов.

### Когда **не** использовать `Iterator`:

*   Если вам не нужно изменять коллекцию во время итерации и вы хотите просто перебрать элементы, можно использовать **`for-each`** цикл, который автоматически использует **`Iterator`** за кулисами.
*   Если коллекция поддерживает индексацию (например, **`List`**), то использование индексов (в цикле **`for`**) может быть более читаемым и эффективным способом перебора.

### Заключение:

**`Iterator`** — это мощный инструмент для перебора коллекций в Java, который предоставляет следующие преимущества:

*   Безопасность при изменении коллекции во время перебора (с помощью метода **`remove()`**).
*   Возможность работы с коллекциями, не поддерживающими индексацию (например, **`Set`**).
*   Полный контроль над процессом итерации, что позволяет выполнять сложные операции или изменять коллекцию на лету.

Используйте **`Iterator`**, когда нужно более гибко управлять процессом перебора или работать с коллекциями без индексации.

## 20. Что такое Map? Что должно быть уникальным? [вопросы](#вопросы)

**`Map`** — это интерфейс в Java, представляющий коллекцию, которая хранит данные в виде пар **ключ-значение**. Это структура данных, в которой каждый **ключ** сопоставлен с **значением**. В отличие от коллекций, таких как **`List`** или **`Set`**, **`Map`** не хранит элементы в виде последовательности, а использует ключи для доступа к значениям.

### Основные характеристики **`Map`**:

*   **Ключи уникальны**: Каждый ключ в **`Map`** должен быть уникальным. То есть в одной коллекции **`Map`** не может быть двух одинаковых ключей. Если вы попытаетесь вставить пару с уже существующим ключом, то старое значение будет перезаписано новым.
    
*   **Значения могут повторяться**: В отличие от ключей, значения, связанные с ключами, могут быть одинаковыми. Коллекция может содержать несколько одинаковых значений, привязанных к разным ключам.
    

### Важные методы интерфейса `Map`:

*   **`put(K key, V value)`** — добавляет пару **ключ-значение** в карту. Если ключ уже существует, старое значение будет заменено на новое.
*   **`get(Object key)`** — возвращает значение, ассоциированное с заданным ключом.
*   **`containsKey(Object key)`** — проверяет, содержится ли ключ в карте.
*   **`containsValue(Object value)`** — проверяет, содержится ли значение в карте.
*   **`remove(Object key)`** — удаляет пару, ассоциированную с данным ключом.
*   **`keySet()`** — возвращает множество всех ключей в карте.
*   **`values()`** — возвращает коллекцию всех значений в карте.
*   **`entrySet()`** — возвращает множество всех пар **ключ-значение** (набор записей).

### Пример использования `Map` (например, **`HashMap`**):

```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Создаем карту
        Map<String, Integer> map = new HashMap<>();
        
        // Добавляем пары ключ-значение
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Orange", 3);
        
        // Получаем значение по ключу
        System.out.println(map.get("Banana"));  // 2
        
        // Проверяем наличие ключа
        System.out.println(map.containsKey("Apple"));  // true
        System.out.println(map.containsKey("Grapes"));  // false
        
        // Проверяем наличие значения
        System.out.println(map.containsValue(3));  // true
        
        // Удаляем элемент
        map.remove("Apple");
        System.out.println(map.get("Apple"));  // null
    }
}
```

### Основные реализации интерфейса `Map`:

1.  **`HashMap`**: Использует хеширование для хранения ключей и значений. Не гарантирует порядка элементов.
    
    *   Пример:
        
        ```java
        Map<String, Integer> map = new HashMap<>();
        ```
        
2.  **`LinkedHashMap`**: Подобно **`HashMap`**, но поддерживает порядок вставки элементов.
    
    *   Пример:
        
        ```java
        Map<String, Integer> map = new LinkedHashMap<>();
        ```
        
3.  **`TreeMap`**: Реализует интерфейс `SortedMap` и хранит ключи в отсортированном порядке.
    
    *   Пример:
        
        ```java
        Map<String, Integer> map = new TreeMap<>();
        ```
        

### Что должно быть уникальным?

*   **Ключи** в **`Map`** должны быть уникальными. Коллекция **`Map`** не допускает наличие одинаковых ключей.
*   **Значения** могут быть не уникальными. Коллекция **`Map`** позволяет несколько раз использовать одно и то же значение, но для разных ключей.

### Заключение:

**`Map`** — это коллекция, которая хранит элементы в виде пар **ключ-значение**, и в этой структуре данных **ключи должны быть уникальными**, в то время как **значения могут повторяться**. Основные реализации **`Map`** включают **`HashMap`**, **`LinkedHashMap`** и **`TreeMap`**, каждая из которых имеет свои особенности и применимость в зависимости от требований к производительности и сортировке данных.

## 21. Может ли null быть ключём в HashMap? [вопросы](#вопросы)


Да, **`null`** может быть ключом в **`HashMap`**.

В **`HashMap`** допускается наличие **одного ключа, равного `null`**. Однако важно понимать, что значение, ассоциированное с этим ключом, также может быть любым, включая `null`. Это отличается от других реализаций **`Map`** (например, **`TreeMap`**), где ключи не могут быть `null`.

### Пример использования `null` в качестве ключа в `HashMap`:

```java
import java.util.HashMap;

public class NullKeyExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        
        // Использование null в качестве ключа
        map.put(null, "Some value");
        
        // Получаем значение по ключу null
        System.out.println(map.get(null));  // "Some value"
        
        // Можно также добавить другие пары ключ-значение
        map.put("Apple", "Fruit");
        map.put("Banana", "Fruit");
        
        System.out.println(map.get("Apple"));  // "Fruit"
        System.out.println(map.get("Banana"));  // "Fruit"
    }
}
```

### Что нужно учитывать:

*   **`null` как ключ**: В **`HashMap`** только один ключ может быть равен `null`. Если вы попытаетесь добавить второй ключ `null`, он заменит предыдущую пару.
*   **`null` как значение**: В **`HashMap`** также могут быть значения, равные `null`, и их может быть несколько. Это значит, что один или несколько ключей могут быть ассоциированы с `null` как значением.

### Заключение:

**`null`** может быть использован как ключ в **`HashMap`**, и для этого не нужно предпринимать дополнительных шагов. **`null`** будет корректно работать как ключ, и **`HashMap`** будет хранить и извлекать связанные с ним значения без проблем.

## можем ли мы добавить пару с null ключём и null значением? И если да то сколько раз?

Да, в **`HashMap`** можно добавить пару с **`null`** как ключом и **`null`** как значением. Однако есть несколько нюансов, которые стоит учесть.

### 1\. **Можно ли добавить пару с `null` ключом и `null` значением?**

Да, можно добавить пару с **`null`** в качестве **ключа** и **`null`** в качестве **значения**. **`HashMap`** позволяет это делать. Например:

```java
import java.util.HashMap;

public class NullKeyValueExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавление пары с null-ключом и null-значением
        map.put(null, null);

        // Получение значения по null-ключу
        System.out.println(map.get(null));  // null
    }
}
```

### 2\. **Сколько раз можно добавить пару с `null` ключом и `null` значением?**

**`HashMap`** позволяет иметь только **один** ключ **`null`** в коллекции. Это означает, что, если вы добавите пару с **`null`** как ключом и **`null`** как значением, и потом попробуете добавить еще одну пару с таким же ключом **`null`**, то **новая пара перезапишет старую**. При этом значение для ключа **`null`** также будет перезаписано.

Пример:

```java
import java.util.HashMap;

public class NullKeyOverwriteExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавление пары с null-ключом и null-значением
        map.put(null, null);

        // Печатаем значение для null-ключа (null)
        System.out.println(map.get(null));  // null

        // Добавляем пару с тем же null-ключом, но с другим значением
        map.put(null, "New Value");

        // Печатаем значение для null-ключа (теперь это "New Value")
        System.out.println(map.get(null));  // "New Value"
    }
}
```

### Вывод:

*   Вы можете добавить пару с **`null`** как ключом и **`null`** как значением **один раз**.
*   Если вы добавите другую пару с **`null`** как ключом, **старое значение будет перезаписано новым**. Таким образом, в **`HashMap`** всегда может быть **только одна пара с `null` ключом**, и она будет содержать последнее добавленное значение.

## Что происходит при перезаписи пошагово? Старое значение просто удалиться и доступ к нему восстановить больше не будет возможным?


Когда вы перезаписываете пару с **`null`** как ключом в **`HashMap`**, происходит несколько шагов, которые можно рассмотреть пошагово:

### 1\. **Изначальная вставка пары с `null` ключом**:

Допустим, вы добавили пару с **`null`** ключом и значением **`null`**:

```java
map.put(null, null);
```

*   В этот момент **`HashMap`** создает внутреннюю запись для пары (ключ, значение) с **`null`** ключом и **`null`** значением.
*   Если в карте ещё нет записи с таким ключом, то создается новая запись, ассоциированная с ключом **`null`**.

### 2\. **Перезапись пары с тем же ключом (`null`)**:

Теперь вы добавляете пару с тем же **`null`** ключом, но с новым значением:

```java
map.put(null, "New Value");
```

*   **`HashMap`** выполняет поиск записи с ключом **`null`** в своей внутренней структуре данных (например, через хеширование).
*   Как только она находит пару с **`null`** ключом, старая запись удаляется.
    *   В случае **`null`** значения, старое значение, которое было **`null`**, больше не хранится в карте.
    *   **`HashMap`** удаляет старое значение, и память, занятая этим значением, освобождается (если на это значение не ссылаются другие объекты).
*   Затем добавляется новая запись с тем же ключом (**`null`**) и новым значением ("New Value").
*   Это новая пара заменяет старую запись, так как ключи в **`Map`** должны быть уникальными.

### 3\. **Как происходит удаление старого значения**:

*   В момент перезаписи, когда **`HashMap`** обновляет запись с ключом **`null`**, старое значение уже **не доступно** в карте. После перезаписи доступ к старому значению (например, `null`) восстановить не получится, так как оно удалено.
*   Это может происходить следующим образом:
    *   В **`HashMap`** каждый элемент (пара ключ-значение) хранится внутри узлов, в которых есть ссылки на ключи и значения.
    *   Когда пара с **`null`** ключом перезаписывается, старое значение удаляется, и память освобождается.

### 4\. **Доступность старого значения**:

После того как пара с **`null`** ключом была перезаписана, старое значение (которое было **`null`** или другим значением) больше не существует в коллекции и не может быть доступно. **Доступ к старому значению восстановить невозможно**, так как оно уже удалено из карты.

### Пример:

```java
import java.util.HashMap;

public class MapOverwriteExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавляем пару с null-ключом и null-значением
        map.put(null, null);

        // Проверяем, что значение для null-ключа равно null
        System.out.println(map.get(null));  // null

        // Перезаписываем пару с тем же ключом, но другим значением
        map.put(null, "New Value");

        // Проверяем, что теперь значение для null-ключа - "New Value"
        System.out.println(map.get(null));  // "New Value"
    }
}
```

### Заключение:

*   Старое значение при перезаписи пары с **`null`** ключом **удаляется** и больше не доступно.
*   **`HashMap`** автоматически освобождает память, занимаемую старой записью, и записывает новую пару с тем же ключом и новым значением.
*   После перезаписи старое значение становится **недоступным**, и доступ к нему восстановить невозможно.

## 22. Как работает HashMap? Расскажите подробно, как работает метод put? Что происходит при коллизии? [вопросы](#вопросы)


### Как работает **`HashMap`** в Java?

**`HashMap`** — это структура данных, которая хранит данные в виде пар **ключ-значение**. Для быстрого поиска значения, связанного с конкретным ключом, **`HashMap`** использует **хеширование**. Это позволяет быстро находить элементы с помощью хеш-функции, которая преобразует ключ в индекс массива. Когда мы добавляем пару ключ-значение в **`HashMap`**, она использует этот индекс для размещения элемента в соответствующем месте массива. Но хеширование может привести к коллизиям, которые **`HashMap`** должна уметь обрабатывать.

### Внутреннее устройство **`HashMap`**:

1.  **Массив узлов**: Внутри **`HashMap`** хранится массив **`Entry[]`**. Каждый элемент массива — это **узел** (или **"bucket"**), который может содержать несколько значений, если произошло столкновение.
2.  **Хеш-функция**: Когда вы добавляете пару ключ-значение, хеш-функция вычисляет хеш-значение для ключа и определяет индекс в массиве для хранения этой пары.
3.  **Перераспределение** (резервирование места): Когда число элементов в **`HashMap`** достигает определенного порога (обычно 75% от текущего размера массива), происходит перераспределение — массив увеличивается, и элементы перераспределяются по новым индексам.

* * *

### Как работает метод **`put(K key, V value)`**?

Метод **`put()`** в **`HashMap`** используется для добавления или обновления элемента в карте. Он работает следующим образом:

1.  **Выбор хеш-индекса**:
    
    *   Метод **`hashCode()`** вызывается на ключе, чтобы вычислить его хеш-код.
    *   Полученный хеш-код обрабатывается через дополнительную хеш-функцию (например, с помощью **`spread()`)**, чтобы получить индекс массива, который будет использоваться для размещения элемента.
    *   Хеш-код и индекс могут быть разными, поскольку индексы массива могут быть вычислены с учетом размеров массива.
2.  **Проверка на существование ключа**:
    
    *   Если в массиве по рассчитанному индексу уже есть узел, то метод будет проверять:
        *   **Если ключ уже существует** в этом месте, то обновляется связанное с ним значение.
        *   Если ключ не найден, то добавляется новый элемент в этот "бакет".
3.  **Обработка коллизий**:
    
    *   Если два разных ключа имеют одинаковый хеш-код (коллизия), **`HashMap`** использует механизм цепочек для хранения нескольких элементов в одном бакете (это может быть связанный список или, начиная с Java 8, сбалансированное дерево).
    *   В старых версиях Java (до 8) коллизии обрабатывались с использованием **связанных списков**. В случае высокой плотности коллизий для улучшения производительности хеш-таблица будет преобразована в **дерево (TreeMap)**, чтобы ускорить поиск.
4.  **Возвращение старого значения**:
    
    *   Если ключ уже был в **`HashMap`**, то старое значение, связанное с этим ключом, будет возвращено и заменено новым значением. Если ключ был добавлен впервые, старое значение будет **`null`**.

### Что происходит при коллизии?

**Коллизия** возникает, когда два или более ключа имеют одинаковое хеш-значение, то есть они приводят к одному и тому же индексу массива.

**Как **`HashMap`** решает коллизии?**

1.  **Цепочки** (Linked List):
    
    *   Если происходит коллизия (т.е. два ключа имеют одинаковый хеш-код и оказываются в одном бакете), **`HashMap`** помещает оба элемента в связанный список (или в другой контейнер, если происходит перераспределение).
    *   Каждый элемент в бакете хранит пару **ключ-значение**, а также ссылку на следующий элемент в цепочке. Так, несколько элементов могут находиться в одном бакете.
2.  **Использование сбалансированного дерева**:
    
    *   В **`HashMap`** начиная с Java 8, если в одном бакете появляется слишком много элементов (порог коллизий), то для улучшения производительности эти элементы могут быть преобразованы в **сбалансированное дерево (например, `TreeMap`)**.
    *   В этом случае, поиск и вставка в бакете с коллизиями будут происходить быстрее, так как дерево имеет логарифмическую сложность O(log n), в отличие от линейного времени в случае связанного списка.
3.  **Перераспределение**:
    
    *   Когда **`HashMap`** достигает определенного порога заполнения (например, 75% от текущего размера), она увеличивает размер массива и перераспределяет элементы по новым индексам. Это может уменьшить вероятность коллизий и улучшить производительность.

* * *

### Пошагово, как работает метод **`put()`**:

1.  **Вычисление хеш-кода**: Метод **`hashCode()`** на ключе вычисляет хеш-код. Этот хеш-код затем трансформируется с помощью дополнительной функции, чтобы избежать потенциальных коллизий.
    
2.  **Получение индекса**: Полученный хеш-код используется для вычисления индекса массива, куда нужно добавить пару **ключ-значение**.
    
3.  **Проверка существования ключа**:
    
    *   Если на этом индексе **`HashMap`** уже хранится элемент с таким ключом, старое значение перезаписывается новым, и старое значение возвращается.
    *   Если ключа нет, создается новый узел и добавляется в массив по вычисленному индексу.
4.  **Обработка коллизий**:
    
    *   Если коллизия (несколько элементов с одинаковым хеш-кодом), добавляется новый элемент в цепочку или дерево, если в бакете много элементов.
5.  **Проверка на перераспределение**:
    
    *   Если заполняемость **`HashMap`** превышает 75%, происходит перераспределение массива (увеличение размера массива и перераспределение элементов).

* * *

### Пример работы метода **`put()`**:

```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();

        // Добавление пар
        map.put("apple", "fruit");
        map.put("carrot", "vegetable");
        map.put("banana", "fruit");
        
        // Перезапись значения по ключу "apple"
        map.put("apple", "green fruit");

        // Обработка коллизий (например, по "apple" и "apple1" одинаковые хеш-коды)
        System.out.println(map);
    }
}
```

* * *

### Заключение:

*   **`HashMap`** использует хеширование для быстрого доступа к элементам, и при коллизиях использует либо цепочки, либо сбалансированные деревья (начиная с Java 8).
*   Метод **`put()`** отвечает за добавление или обновление элементов и автоматически решает коллизии, помещая их в цепочки или деревья для оптимизации поиска.
*   В случае перераспределения, **`HashMap`** увеличивает размер массива, чтобы уменьшить вероятность коллизий и повысить производительность.

## "сбалансированное дерево" Что это такое? Какие бывают деревья?


**Сбалансированное дерево** — это тип структуры данных, в которой элементы организованы в виде дерева, и оно поддерживает баланс, чтобы гарантировать эффективный поиск, вставку и удаление. В сбалансированном дереве глубина дерева или высота поддеревьев ограничена таким образом, чтобы операции с ним выполнялись за логарифмическое время  $O(\log n)$ , где  $n$  — количество элементов.

### Основные типы сбалансированных деревьев:

1.  **AVL-дерево**:
    
    *   **AVL** (от англ. **Adelson-Velsky and Landis**) — это двоичное дерево поиска (BST), в котором для каждого узла выполняется условие: разница в высоте левого и правого поддерева не превышает 1.
    *   Это дерево называется **само-сбалансирующимся**: после каждой операции вставки или удаления проверяется баланс каждого узла, и если баланс нарушен, дерево **перебалансировывается** с помощью поворотов.
    
    **Преимущества**:
    
    *   Быстрое выполнение операций  $O(\log n)$ .
    *   Хорошо сбалансировано для быстрых поисков и обновлений.
    
    **Недостатки**:
    
    *   Требует дополнительных вычислений для балансировки, что делает его немного медленнее при вставке или удалении по сравнению с другими деревьями.
2.  **Красно-черное дерево (Red-Black Tree)**:
    
    *   **Красно-черное дерево** — это тоже двоичное дерево поиска, но с дополнительными ограничениями на цвета узлов:
        *   Каждый узел окрашен в **красный** или **черный** цвет.
        *   Корень дерева всегда черный.
        *   Все листья (пустые узлы) черные.
        *   Если узел красный, то оба его потомка должны быть черными.
        *   Для каждого узла от него до всех его листьев должен быть одинаковое количество черных узлов.
    
    **Преимущества**:
    
    *   Сравнительно прост в реализации и поддерживает операции поиска, вставки и удаления за  $O(\log n)$ .
    *   Меньше поворотов по сравнению с AVL-деревьями.
    
    **Недостатки**:
    
    *   Меньше сбалансировано по сравнению с AVL-деревом, что может повлиять на время выполнения операций.
3.  **Баланcированное дерево B-дерево**:
    
    *   **B-дерево** — это обобщение двоичного дерева, которое позволяет хранить более одного элемента в каждом узле. Это дерево используется в базах данных и файловых системах, поскольку оно хорошо работает с большими объемами данных, расположенными на диске.
    *   B-деревья поддерживают балансировку с помощью разбиения узлов, чтобы все листья находились на одинаковой глубине.
    
    **Преимущества**:
    
    *   Подходит для работы с внешней памятью (например, файловыми системами).
    *   Сбалансированное дерево с возможностью хранить много элементов в одном узле, что уменьшает количество операций с диском.
    
    **Недостатки**:
    
    *   Более сложная структура по сравнению с двоичными деревьями поиска.
4.  **Splay-дерево (Splay Tree)**:
    
    *   **Splay-дерево** — это самобалансирующееся двоичное дерево поиска, в котором каждый раз, когда узел запрашивается, он перемещается в корень дерева с помощью операции "сплея" (вращение).
    
    **Преимущества**:
    
    *   Очень простая реализация.
    *   Может быть эффективным, если доступ к данным часто осуществляется к недавно использованным узлам.
    
    **Недостатки**:
    
    *   Может не гарантировать  $O(\log n)$  для всех операций в худшем случае, так как при некоторых операциях дерево может быть сильно несбалансированным.

### Преимущества сбалансированных деревьев:

*   **Поиск**: Все операции (поиск, вставка и удаление) выполняются за **логарифмическое время**  $O(\log n)$ , что значительно быстрее, чем в несбалансированных деревьях.
*   **Обновление**: Быстрая вставка и удаление элементов, что полезно в реальных приложениях, таких как базы данных, кэширование и обработка запросов.

### Заключение:

Сбалансированные деревья обеспечивают быстрые операции с данными за счет поддержания логарифмической высоты дерева. Они используются в тех случаях, когда важно, чтобы операции поиска, вставки и удаления выполнялись эффективно, независимо от последовательности операций.

## добавляется новый элемент в цепочку или дерево, если в бакете много элементов. Много это сколько? И расскажи подробнее про формирования дерева в этой структуре?


Когда я говорю, что "много элементов в бакете", это связано с тем, как **`HashMap`** обрабатывает коллизии (когда несколько ключей имеют одинаковые хеш-коды). Если в одном бакете много элементов (т.е. произошло слишком много коллизий), **`HashMap`** может преобразовать этот бакет в **сбалансированное дерево** (например, **`TreeMap`**) для улучшения производительности.

### Когда происходит преобразование в сбалансированное дерево?

Перевод в сбалансированное дерево в **`HashMap`** происходит при следующем условии:

*   Если в одном бакете оказалось **более 8 элементов** (обычно это значение по умолчанию в Java 8 и выше), то **`HashMap`** заменяет связанный список на сбалансированное дерево (например, **`TreeMap`**).
*   Если количество элементов в бакете после перераспределения остается менее 6, то **`HashMap`** снова использует связанный список.

Преобразование в дерево важно, так как операция поиска в сбалансированном дереве выполняется за  $O(\log n)$ , что гораздо быстрее линейного времени  $O(n)$ , которое характерно для поиска по связанным спискам. Таким образом, когда количество коллизий слишком велико, производительность операций с этим бакетом значительно снижается, и переход к дереву помогает сохранить эффективность.

### Формирование дерева в **`HashMap`**:

1.  **Коллизия**: Когда два или более элемента имеют одинаковый хеш-код, они попадают в один и тот же бакет. На начальном этапе такие элементы хранятся в **связанном списке**, поскольку это простая и быстрая структура для добавления элементов в бакет.
    
2.  **Порог коллизий**: Когда в одном бакете оказывается более 8 элементов, **`HashMap`** решает, что эффективность связанного списка ухудшается, и преобразует его в сбалансированное дерево. Это происходит автоматически, чтобы ускорить операции поиска, вставки и удаления.
    
3.  **Преобразование в сбалансированное дерево**: Для каждого бакета, где количество элементов превысило порог, **`HashMap`** использует **`TreeMap`** — это дерево, которое хранит элементы в порядке ключей и автоматически поддерживает баланс. В **`TreeMap`** используется алгоритм **Красно-черного дерева**, что позволяет гарантировать, что высота дерева всегда будет оставаться сбалансированной (в пределах  $O(\log n)$ ).
    
4.  **Вставка и поиск**: После преобразования бакета в сбалансированное дерево, поиск, вставка и удаление элементов в этом бакете будут выполняться гораздо быстрее, так как операции с деревом выполняются за  $O(\log n)$ , в отличие от линейных операций в связанном списке.
    
5.  **Возвращение к связанному списку**: Если в бакете становится менее 6 элементов после перераспределения, **`HashMap`** снова преобразует сбалансированное дерево в связанный список. Это помогает сэкономить память и предотвратить ненужное усложнение структуры, когда коллизий меньше.
    

### Пример:

Предположим, что у нас есть **`HashMap`**, и несколько элементов имеют одинаковый хеш-код. Изначально, элементы будут храниться в одном бакете в виде связанного списка.

```java
import java.util.HashMap;

public class HashMapCollisions {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        
        // Пример добавления элементов, которые могут привести к коллизиям
        map.put("apple", "fruit");
        map.put("applf", "fruit");  // Коллизия (предположим, одинаковый хеш-код)
        map.put("applg", "fruit");
        map.put("appleh", "fruit");
        map.put("applei", "fruit");
        map.put("applej", "fruit");
        map.put("applek", "fruit");
        map.put("applel", "fruit");
        
        // Если в одном бакете будет больше 8 элементов, они могут быть переведены в сбалансированное дерево
    }
}
```

Если количество элементов в бакете превысит 8, **`HashMap`** преобразует этот бакет в сбалансированное дерево.

* * *

### Заключение:

*   В **`HashMap`** преобразование бакета в сбалансированное дерево происходит, когда в одном бакете появляется **более 8 элементов**, чтобы избежать деградации производительности при поиске.
*   Сбалансированное дерево улучшает время поиска с линейного до логарифмического  $O(\log n)$ , что особенно полезно при большом количестве коллизий.
*   Когда количество элементов уменьшается до 6 и менее, бакет снова преобразуется в связанный список, чтобы сэкономить память и ресурсы.

## какая иерархия времени поиска? Что быстрее а что медленнее?


### Иерархия времени поиска в различных структурах данных

Время поиска зависит от того, как устроена структура данных и как эффективно она поддерживает доступ к элементам. Рассмотрим различные структуры данных с точки зрения их сложности поиска.

#### 1\. **Массив (Array)**

*   **Поиск элемента по индексу (по месту)** — **O(1)**.
    
    *   Если вам нужно получить доступ к элементу по его индексу, это происходит за постоянное время  $O(1)$ , так как элементы массива хранятся в смежных ячейках памяти.
*   **Поиск элемента по значению (линейный поиск)** — **O(n)**.
    
    *   Для поиска элемента по значению в массиве (если он не отсортирован), нужно пройти через все элементы массива, что занимает линейное время  $O(n)$ .

#### 2\. **Связанный список (Linked List)**

*   **Поиск элемента (линейный поиск)** — **O(n)**.
    *   В связанном списке элементы хранятся в виде узлов, и для поиска нужно пройти по всем узлам до нахождения нужного элемента.

#### 3\. **Двоичное дерево поиска (Binary Search Tree, BST)**

*   **Поиск** — **O(h)**, где  $h$  — высота дерева.
    *   В обычном **двоичном дереве поиска** (не сбалансированном) поиск будет занимать время, пропорциональное высоте дерева  $h$ . Если дерево сильно несбалансировано, высота может быть  $O(n)$ , и поиск будет линейным по времени. В идеале для сбалансированного дерева высота будет  $O(\log n)$ .

#### 4\. **Красно-черное дерево (Red-Black Tree)**

*   **Поиск** — **O(\\log n)**.
    *   **Красно-черное дерево** — это сбалансированное дерево поиска. Его высота всегда ограничена  $O(\log n)$ , что гарантирует логарифмическое время поиска.

#### 5\. **AVL-дерево**

*   **Поиск** — **O(\\log n)**.
    *   **AVL-дерево** — это самобалансирующееся двоичное дерево поиска, где высота также всегда ограничена  $O(\log n)$ , обеспечивая логарифмическое время поиска.

#### 6\. **Хеш-таблица (Hash Table)**

*   **Поиск** — **O(1)** в среднем (при условии хорошего хеширования).
    *   В **хеш-таблицах** время поиска в среднем составляет  $O(1)$ , так как элементы распределяются по индексам на основе их хеш-кода. Однако в худшем случае (например, при сильных коллизиях) время поиска может быть  $O(n)$  (например, если все элементы попали в один бакет и используются связанные списки).

#### 7\. **Множество (HashSet, TreeSet)**

*   **HashSet**:
    *   **Поиск** — **O(1)** в среднем (при хорошем хешировании).
    *   **TreeSet** (основан на **TreeMap**):
    *   **Поиск** — **O(\\log n)**.

#### 8\. **Массив, отсортированный для бинарного поиска**

*   **Бинарный поиск** — **O(\\log n)**.
    *   Для отсортированного массива или списка можно применить **бинарный поиск**, который находит элемент за логарифмическое время  $O(\log n)$ , проверяя средний элемент и сокращая область поиска вдвое.

#### 9\. **Priority Queue (Очередь с приоритетом)**

*   **Поиск элемента** — **O(n)**.
    *   В **очереди с приоритетом** (например, **Heap**) поиск элемента (кроме минимального/максимального) выполняется за линейное время  $O(n)$ , так как структура не поддерживает быстрый произвольный доступ к элементам.

* * *

### Сравнение времени поиска по типам структур данных

| Структура данных | Время поиска (по значению) | Примечания |
| --- | --- | --- |
| **Массив** | O(1) (по индексу), O(n) (по значению) | Быстро по индексу, медленно по значению. |
| **Связанный список** | O(n) | Линейный поиск по элементам. |
| **Двоичное дерево поиска (BST)** | O(h), где h — высота дерева | Может быть O(n) в худшем случае (несбалансированное дерево). |
| **Красно-черное дерево** | O(log n) | Сбалансированное дерево поиска. |
| **AVL-дерево** | O(log n) | Сбалансированное дерево поиска. |
| **Хеш-таблица** | O(1) (в среднем) | Очень быстро при хорошем хешировании. |
| **TreeSet (сбалансированное дерево)** | O(log n) | Дерево, поддерживающее сортировку. |
| **Отсортированный массив (для бинарного поиска)** | O(log n) | Требуется предварительная сортировка. |
| **Очередь с приоритетом (Heap)** | O(n) | Невозможно быстро найти произвольный элемент. |

* * *

### Заключение:

*   **Быстрее**: **Хеш-таблицы (HashMap)** и **массивы** (по индексу) обеспечивают самый быстрый поиск в большинстве случаев.
*   **Медленнее**: **Связанные списки** и **очереди с приоритетом** имеют линейное время поиска  $O(n)$ , что делает их менее эффективными для поиска элементов.
*   **Логарифмическое время** ( $O(\log n)$ ): достигается в **сбалансированных деревьях** (например, **красно-черные деревья**, **AVL-деревья**, **TreeSet**) и при использовании **бинарного поиска** в отсортированных массивах.

Для задач, где важна скорость поиска, часто выбирают **хеш-таблицы**. Для сортированных данных или когда порядок элементов важен, используются **сбалансированные деревья**.

## Красно-черное дерево. Можешь рассказать подробно про его работу?


### Красно-черное дерево (Red-Black Tree)

**Красно-черное дерево** — это **самобалансирующееся двоичное дерево поиска**, которое удовлетворяет набору специфических свойств, благодаря которым оно остается сбалансированным. Эти свойства помогают обеспечить, что время поиска, вставки и удаления элементов всегда будет  $O(\log n)$ , где  $n$  — количество элементов в дереве.

Красно-черное дерево активно используется в реализации таких коллекций, как **TreeMap** и **TreeSet** в Java.

### Свойства красно-черного дерева:

1.  **Каждый узел имеет цвет**:
    
    *   Каждый узел может быть либо **красным**, либо **черным**.
2.  **Корень дерева всегда черный**:
    
    *   Корень дерева всегда имеет черный цвет. Это свойство помогает сохранить баланс дерева с самого начала.
3.  **Листья (пустые узлы) черные**:
    
    *   Все листья, которые представляют собой пустые указатели (или `null`), считаются черными. Это важно для определения баланса дерева.
4.  **Красные узлы не могут быть соседями**:
    
    *   Если узел красный, то оба его потомка (дети) должны быть черными. Это гарантирует, что два красных узла не могут быть рядом, что помогает избежать сильно «вытянутых» деревьев, тем самым контролируя высоту.
5.  **Черная глубина одинакова для всех путей от любого узла до его листьев**:
    
    *   Для каждого пути от узла до любого из его листьев количество черных узлов (черная глубина) должно быть одинаковым. Это ограничивает максимальную высоту дерева, что позволяет гарантировать логарифмическую сложность поиска.
6.  **Балансировка дерева**:
    
    *   В отличие от **AVL-деревьев**, где балансировка каждого узла производится после каждой вставки или удаления, в **красно-черном дереве** балансировка происходит реже и требует меньше переработок. Это делает красно-черное дерево более производительным при вставке и удалении.

### Операции в красно-черном дереве

1.  **Вставка элемента**:
    
    *   Вставка нового элемента в красно-черное дерево начинается как обычная вставка в обычное двоичное дерево поиска (BST), то есть новый элемент помещается в соответствующий узел на основе его ключа.
    *   После вставки элемент всегда имеет красный цвет (это помогает минимизировать количество изменений при балансировке).
    *   Затем дерево должно пройти через процесс балансировки, чтобы удовлетворить все свойства красно-черного дерева. Балансировка включает в себя **повороты** и **перекраску** узлов.
    
    **Процесс балансировки**:
    
    *   **Повороты**: Если дерево нарушает баланс, производится один или два поворота. В зависимости от ситуации могут быть использованы:
        *   **Левый поворот**.
        *   **Правый поворот**.
    *   **Перекраска**: Узлы могут менять свой цвет, чтобы восстановить свойства дерева (например, красные узлы могут стать черными).
2.  **Удаление элемента**:
    
    *   Удаление в красно-черном дереве работает аналогично удалению в обычном двоичном дереве поиска. После удаления элемента необходимо выполнить балансировку дерева.
    *   В отличие от вставки, удаление требует больше переработок, так как необходимо восстановить баланс дерева. В некоторых случаях может потребоваться несколько поворотов и перекраска узлов.
3.  **Поиск элемента**:
    
    *   Поиск элемента в красно-черном дереве аналогичен поиску в обычном двоичном дереве поиска. Начинается с корня, и дерево обходит влево или вправо в зависимости от значения искомого ключа.
    *   Поскольку дерево сбалансировано, поиск всегда выполняется за ** $O(\log n)$ **.

### Повороты в красно-черном дереве

Повороты (или **ротации**) играют ключевую роль в поддержании сбалансированности дерева при вставке и удалении элементов. Рассмотрим два основных типа поворотов:

1.  **Правый поворот (Right Rotation)**:
    
    *   Это поворот вокруг узла, где левый потомок становится новым родителем, а сам родитель становится правым потомком.
        
    *   Пример:
        
        ```
           10
          /  
         5   
        /     
        ```
        
    
    3
    
    После правого поворота: 5 /  
    3 10
    
2.  **Левый поворот (Left Rotation)**:
    
    *   Это обратная операция правого поворота. Поворот вокруг узла, где правый потомок становится новым родителем, а сам родитель становится левым потомком.
        
    *   Пример:
        
        ```
         5
        /  \
        ```
        
    
    3 10
    
    После левого поворота: 10 /  
    5 / 3
    

### Балансировка после вставки

После вставки нового узла с красным цветом, дерево может нарушить свои свойства. Для восстановления баланса применяется несколько сценариев:

1.  **Ситуация 1: Родитель и дядя узлы — оба красные**:
    
    *   В этом случае происходит перекраска: родитель и дядя становятся черными, а дедушка становится красным.
    *   Далее мы перемещаемся вверх по дереву и продолжаем процесс, пока не восстановим все свойства.
2.  **Ситуация 2: Родитель — красный, а дядя — черный**:
    
    *   Это более сложная ситуация, которая требует поворота (правый или левый) в зависимости от положения узлов.

### Преимущества красно-черного дерева

1.  **Гарантированная логарифмическая высота**:
    
    *   Высота дерева всегда ограничена  $O(\log n)$ , что гарантирует быстроту всех операций — поиска, вставки и удаления.
2.  **Меньше поворотов, чем в AVL-деревьях**:
    
    *   Красно-черные деревья балансируются с меньшими затратами, так как балансировка выполняется не так часто, как в AVL-деревьях.
3.  **Простота реализации**:
    
    *   Сравнительно простая реализация, по сравнению с более строгими сбалансированными деревьями, такими как AVL-деревья.
4.  **Использование в реальных приложениях**:
    
    *   Красно-черные деревья широко используются в таких структурах данных, как **TreeMap** и **TreeSet** в Java, а также в других библиотеках и приложениях.

### Недостатки красно-черного дерева

1.  **Меньшая степень сбалансированности, чем у AVL-дерева**:
    *   Хотя красно-черное дерево всегда имеет высоту  $O(\log n)$ , оно может быть менее сбалансированным, чем AVL-дерево, что в редких случаях может привести к чуть большему времени выполнения операций.

* * *

### Заключение

Красно-черное дерево — это эффективная структура данных для поиска, вставки и удаления, которая сочетает в себе сбалансированность и производительность. Благодаря логарифмической высоте и минимальному количеству переработок при балансировке, красно-черные деревья часто используются в приложениях, где важна скорость обработки данных, например, в **TreeMap** и **TreeSet** в Java.


### а также в других библиотеках и приложениях. "например"



Примером использования **красно-черных деревьев** в различных приложениях и библиотеках могут служить следующие случаи:

1.  **Java Collections Framework**:
    
    *   В Java **TreeMap** и **TreeSet** основаны на красно-черных деревьях. Это означает, что все операции, связанные с вставкой, удалением и поиском элементов в этих коллекциях, выполняются за время  $O(\log n)$ .
    *   **TreeMap** используется для хранения пар "ключ-значение" в отсортированном порядке, а **TreeSet** — для хранения уникальных элементов в отсортированном порядке.
2.  **C++ STL (Standard Template Library)**:
    
    *   В C++ **std::map** и **std::set** также основаны на сбалансированных деревьях, включая красно-черные деревья. Эти структуры данных предоставляют возможности для эффективной сортировки и поиска.
3.  **Базы данных**:
    
    *   В некоторых базах данных, таких как **Redis** и **MongoDB**, используются структуры данных, похожие на красно-черные деревья, для организации индексов. Это позволяет эффективно искать данные и выполнять операции сортировки.
4.  **Кэширование и индексирование**:
    
    *   Красно-черные деревья также могут использоваться для создания эффективных алгоритмов кэширования и индексирования в различных системах хранения данных, таких как файловые системы и индексы поисковых систем.
5.  **Многозадачные системы**:
    
    *   В многозадачных системах красно-черные деревья могут применяться для реализации различных очередей с приоритетом, где необходим быстрый доступ к элементам с различными приоритетами.

Эти примеры показывают, как красно-черные деревья являются важной частью многих библиотек и приложений, где требуется эффективная организация и поиск данных.

## 23. Как работает метод get в HashMap? [вопросы](#вопросы)


Метод **`get(key)`** в **`HashMap`** используется для получения значения, связанного с определённым ключом. Чтобы понять, как работает этот метод, нужно разобрать несколько шагов, которые происходят при его вызове.

### Алгоритм работы метода **`get(key)`** в **`HashMap`**:

1.  **Хеширование ключа**:
    
    *   Когда вызывается метод `get(key)`, сначала вызывается **хеш-функция** для ключа, чтобы вычислить его хеш-код. Хеш-код — это числовое значение, которое используется для определения местоположения в **массиве бакетов** (bucket array), где будет храниться элемент.
    *   Хеш-функция может модифицировать результат хеш-кода (например, применяя побитовые операции), чтобы уменьшить вероятность коллизий и улучшить равномерность распределения ключей по бакетам.
2.  **Вычисление индекса**:
    
    *   После получения хеш-кода вычисляется индекс в массиве бакетов, используя хеш-код. Обычно для этого хеш-код подвергается побитовой операции (например, побитовая маска) для получения индекса в пределах размера массива бакетов. Это помогает правильно распределить элементы по бакетам.
    *   Индекс бакета можно рассчитать так:
        
        ```java
        int index = (n - 1) & hash;
        ```
        
        где `n` — это размер массива бакетов, а `hash` — это хеш-код ключа.
3.  **Поиск в бакете**:
    
    *   После того как был вычислен индекс бакета, HashMap смотрит на соответствующий бакет в массиве.
    *   В случае отсутствия коллизий (когда в бакете хранится только один элемент), элемент с искомым ключом будет найден сразу.
    *   В случае коллизий (когда несколько элементов хранятся в одном бакете) может быть использована одна из следующих техник:
        *   **Список**: Ранее версии HashMap использовали связанный список для хранения элементов с одинаковым хеш-кодом. Тогда HashMap будет перебирать элементы списка, пока не найдет нужный ключ.
        *   **Дерево** (в новых версиях, начиная с Java 8): Если в бакете хранится более 8 элементов, то элементы начинают храниться в виде **красно-черного дерева**, что улучшает скорость поиска.
4.  **Сравнение ключей**:
    
    *   После того как HashMap находит элемент с соответствующим хеш-кодом в бакете, он сравнивает ключи с помощью метода **`equals()`**.
    *   Если ключи совпадают, то возвращается связанное с ним значение.
    *   Если ключи не совпадают, HashMap продолжает искать в бакете (в случае списка или дерева).
5.  **Возврат значения**:
    
    *   Если ключ найден, метод возвращает значение, связанное с этим ключом.
    *   Если ключ не найден, метод возвращает `null`.

### Пример работы метода **`get()`**:

Предположим, у нас есть `HashMap` с несколькими элементами:

```java
HashMap<String, Integer> map = new HashMap<>();
map.put("Apple", 10);
map.put("Banana", 20);
map.put("Orange", 30);
```

Теперь, если вызвать `get("Banana")`, происходит следующее:

1.  Вычисляется хеш-код для ключа `"Banana"`.
2.  Индекс в массиве бакетов вычисляется с использованием хеш-кода.
3.  В бакете, соответствующем вычисленному индексу, происходит поиск элемента с ключом `"Banana"`.
4.  С помощью метода `equals()` ключ `"Banana"` сравнивается с другими ключами, если в бакете несколько элементов.
5.  Когда ключ совпадает, метод возвращает значение `20`.

### Важные аспекты:

*   **Хеширование**: Главное преимущество `HashMap` — это использование хеширования для быстрого поиска. Это делает поиск в среднем очень быстрым — **O(1)**, если коллизий мало.
*   **Коллизии**: В случае коллизий скорость поиска может ухудшаться. В старых версиях Java элементы с одинаковым хеш-кодом хранились в виде связанного списка, что приводило к времени поиска **O(n)** в худшем случае. В современных версиях, если количество элементов в бакете превышает 8, используется красно-черное дерево, что делает время поиска **O(log n)** в худшем случае.
*   **Производительность**: Время выполнения метода `get()` зависит от качества хеш-функции, которая должна равномерно распределять ключи по бакетам. Чем меньше коллизий, тем быстрее работает метод.

### Итог:

Метод **`get(key)`** в **`HashMap`** работает следующим образом:

1.  Вычисляется хеш-код для ключа.
2.  На основе хеш-кода вычисляется индекс в массиве бакетов.
3.  Ищется элемент в бакете с соответствующим индексом.
4.  При совпадении ключа с искомым значением возвращается связанное с ним значение, иначе — `null`.
